<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>DjVu Reference</title>
<style>
#about { margin: 0 auto; max-width: 65%; border: 1px solid black; font-size: larger; padding: 1rem; background-color: pink; }
.hex, .ck, .ty { font-family: monospace; }
.ty { text-decoration: underline dotted; }
a.bare, .filename { font-family: sans-serif; }
dt { font-style: italic; }
table.hoist td:nth-child(1) { vertical-align: top; }
h1 small, h2 small, h3 small, h4 small, h5 small, h6 small { font-weight: normal; }
</style>
</head>
<body>
<div id="about">
This is an unofficial transcription, with minor orthographic and stylistic changes, of the <a href="./DjVu3Spec.djvu">Celartem/Lizardtech DjVu Reference, version 3</a>. Official information about DjVu is available at <a class="bare" href="http://djvu.sourceforge.net">djvu.sourceforge.net</a>.
</div>

<h1>DjVu Reference</h1>

<table>
<tr><td>Document Date:</td><td>November 2005</td></tr>
<tr><td>From:</td><td>Lizardtech, a Celartem Company</td></tr>
<tr><td>Status of Standard:</td><td>Released</td></tr>
</table>

<section id="1">
<h2><a href="#1">1</a> Introduction <small>[<a href="#">top</a>]</small></h2>
<p>Although the Internet has given us a worldwide infrastructure on which to build the universal library, much of the world’s knowledge, history, and literature is still trapped on paper in the basements of the world’s traditional libraries. Many libraries and content owners are in the process of digitizing their collections. While many such efforts involve the painstaking process of converting paper documents to computer-friendly form, such as SGML-based formats, the high cost of such conversions limits their extent. Scanning documents and distributing the resulting images electronically is not only considerably cheaper, but also more faithful to the original document because it preserves its visual aspect.</p>
<p>Despite the quickly-improving speed of network connections and computers, the number of scanned document images accessible on the Web today is relatively small. There are several reasons for this.</p>
<p>The first reason is the relatively high cost of scanning anything else but unbound sheets in black and white. This problem is slowly going away with the appearance of fast and low-cost color scanners with sheet feeders.</p>
<p>The second reason is that long-established image compression standards and file formats have proved inadequate for distributing scanned documents at high resolution, particularly color documents. Not only are the file sizes and download times impractical, the decoding and rendering times are also prohibitive. A typical magazine page scanned in color at 100 dpi in JPEG would typically occupy 100 KB to 200 KB, but the text would be hardly readable: insufficient for screen viewing and totally unacceptable for printing. The same page at 300 dpi would have sufficient quality for viewing and printing, but the file size would be 300 KB to 1000 KB at best, which is impractical for remote access. Another major problem is that a fully-decoded 300 dpi color image of a letter-size page occupies 24 MB of memory and easily causes disk swapping.</p>
<p>The third reason is that digital documents are more than just a collection of individual page images. Pages in a scanned document have a natural serial order. Special provision must be made to ensure that flipping pages be instantaneous and effortless so as to maintain a good user experience. Even more important, most existing document formats force users to download the entire document first before displaying a chosen page. However, users often want to jump to individual pages of the document without waiting for the entire document to download. Efficient browsing requires efficient random page access, fast sequential page flipping, and quick rendering. This can be achieved with a combination of advanced compression, pre-fetching, pre-decoding, caching, and progressive rendering. DjVu decomposes each page into multiple components (text, backgrounds, images, libraries of common shapes…) that may be shared by several pages and downloaded on demand. This allows a suitably designed DjVu-viewing application to handle on-demand downloading, pre-fetching, decoding, caching, and progressive rendering of the page images.</p>
</section><!-- 1 -->

<section id="2">
<h2><a href="#2">2</a> Document organization <small>[<a href="#">top</a>]</small></h2>
<p>This document describes the DjVu file format. It is written “from top down”, providing first a high-level understanding of the features and techniques used in DjVu (see §<a href="#3">3</a>), then a mid-level view at the IFF85 level (see §<a href="#7">7</a>), and finally a very detailed description of the underlying algorithms and byte-by-byte makeup of DjVu files (see §<a href="#8">8</a>).</p>
</section><!-- 2 -->

<section id="3">
<h2><a href="#3">3</a> Overview <small>[<a href="#">top</a>]</small></h2>
<p>This section describes the DjVu file format at a high level: how DjVu uses the Mixed Raster Content model, how images are composed into documents, and the non-raster data that such documents can also contain.

<section id="3.1">
<h3><a href="#3.1">3.1</a> DjVu images</h3>
<p>The principal imaging model used in DjVu is the “Mixed Raster Content” (MRC) model described in <a href="https://www.itu.int/rec/T-REC-T.44">ITU-T Recommendation T.44</a>, <a href="https://www.iso.org/standard/32228.html">ISO/IEC 16485</a>. In this model, an image is decomposed into foreground and background layers. To select whether a particular pixel comes from the foreground or background, a bitonal “selection” or “mask” layer is provided. These three layers are compressed separately using techniques which are optimized for each type of data.</p>
<p>The foreground and background layers are compressed using a wavelet-based continuous-tone image compression technique known as “IW44”.</p>
<p>The mask layer is compressed using a bitonal image compression technique that takes advantage of repetitions of nearly identical shapes on the page (such as characters) to efficiently compress text images.</p>
<p>A DjVu image need not contain all three layers and alternative compression techniques are available for each layer.</p>
</section><!-- 3.1 -->

<section id="3.2">
<h3><a href="#3.2">3.2</a> DjVu documents</h3>
<p>DjVu documents can be single- or multi-page. Each page consists of a DjVu image as described above (photo, bitonal, or an MRC-based composition). Such a page, by itself, is a valid DjVu document. Multi-page documents can take either of two forms: bundled or indirect.</p>

<section id="3.2.1">
<h4><a href="#3.2.1">3.2.1</a> Bundled multi-page documents</h4>
<p>A bundled multi-page DjVu document uses a single file to represent the entire document. This single file contains all the pages as well as ancillary information (e.g.&nbsp;the page directory, data shared by several pages, thumbnails, etc.). Using a single-file format is very convenient for storing documents or for sending email attachments.</p>
</section><!-- 3.2.1 -->

<section id="3.2.2">
<h4><a href="#3.2.2">3.2.2</a> Indirect multi-page documents</h4>
<p>There are problems inherent to storing multiple pages in a single file. A viewer may not be able to utilize a byte-serving mechanism such as that available in HTTP/1.1. Therefore any request for any page of such a file will necessarily result in the entire document being transmitted. Furthermore, a reasonable work pattern is to read the first few pages (perhaps a table of contents) and then navigate to a page much further into the document. However, in such a file, data for page 100 can not be viewed until after data for pages 1–99 have been downloaded.</p>
<p>Indirect multi-page documents address these problems. Such a document is composed of several files. The main file is named the index file. You can view document using the URL of the index file, just like you do with a bundled multi-page document. However, the index file is very small. It simply contains the document directory and the URLs of secondary files containing the page data. When you view an indirect multi-page document, the viewer only needs to download the files corresponding to the pages you are viewing.</p>
</section><!-- 3.2.2 -->
</section><!-- 3.2 -->

<section id="3.3">
<h3><a href="#3.3">3.3</a> Non-raster data</h3>

<section id="3.3.1">
<h4><a href="#3.3.1">3.3.1</a> Annotations</h4>
<p>Every DjVu image optionally includes several different kinds of annotations. These annotations are often used to define hyperlinks to other document pages or to arbitrary Web pages. They can also be used for other purposes such as setting the initial viewing mode of a page and defining highlighted zones.</p>
</section><!-- 3.3.1 -->

<section id="3.3.2">
<h4><a href="#3.3.2">3.3.2</a> Hidden text</h4>
<p>Every DjVu image optionally includes a hidden text layer that associates graphical features with the corresponding text. The hidden text layer is usually generated by running optical character recognition software. This textual information provides for indexing DjVu documents and copying/pasting text from DjVu page images.</p>
</section><!-- 3.3.2 -->

<section id="3.3.3">
<h4><a href="#3.3.3">3.3.3</a> Thumbnails</h4>
<p>DjVu documents sometimes contain pre-computed page thumbnails. These allow a viewer to display a graphical representation of many pages by downloading a very small “thumbnail” file instead of the actual pages themselves.</p>
</section><!-- 3.3.3 -->
</section><!-- 3.3 -->
</section><!-- 3 -->

<section id="4" >
<h2><a href="#4">4</a> What’s new in the DjVu file format <small>[<a href="#">top</a>]</small></h2>
<p>Since the last update to the file format documentation, <a href="#6.1">Reference 1</a>, the file format has been extended to include:</p>
<dl>

<dt>Multi-page formats</dt>
<dd>DjVu documents can span more than one page. There are two multi-page formats available: bundled (single file) and indirect (separate file for each page). See §<a href="#3.2">3.2</a> and §<a href="#7.2">7.2</a>.</dd>

<dt>Annotations</dt>
<dd>Both initial viewing parameters (background color, initial zoom) and overlayed annotations (hyperlinks, text boxes) can be specified either at the document level (“shared”) or at the page level. See §<a href="#8.3.4">8.3.4</a>.</dd>

<dt>Hidden text</dt>
<dd>Text and the associated layout information can be stored with each image. This allows documents to be searched and indexed. See §<a href="#8.3.5">8.3.5</a>.</dd>

<dt>Document outline</dt>
<dd>A hierarchical outline can be specified at the document level. This allows the document to present an integrated outline for overview and navigation. See §<a href="#8.3.3">8.3.3</a>.</dd>

<dt>Colorized JB2</dt>
<dd>A palettized extension is provided for the bitonal encoder. See §<a href="#8.3.10">8.3.10</a>.</dd>

</dl>
</section><!-- 4 -->

<section id="5">
<h2><a href="#5">5</a> Acknowledgements <small>[<a href="#">top</a>]</small></h2>
<p>This work is significantly based on <a href="#6.1">Reference 1</a> and the summary of file format changes described in the DjVuLibre project maintained by Leon Bottou and others.</p>
</section><!-- 5 -->

<section id="6">
<h2><a href="#6">6</a> References <small>[<a href="#">top</a>]</small></h2>

<section id="6.1">
<h3><a href="#6.1">6.1</a> DjVu 2</h3>
<p>The DjVu file format specification that was originally released by AT&amp;T in 1999. <a class="bare" href="http://djvuzone.org/djvu/djvu/djvuspec/001.djvu">http://djvuzone.org/djvu/djvu/djvuspec/001.djvu</a></p>
</section><!-- 6.1 -->

<section id="6.2">
<h3><a href="#6.2">6.2</a> IFF</h3>
<p>EA IFF 85 format, Electronic Arts’ public-domain IFF standard for an Interchange File Format, released in January, 1985. <a class="bare" href="http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt">http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/IFF.txt</a></p>
</section><!-- 6.2 -->

<section id="6.3">
<h3><a href="#6.3">6.3</a> JPEG</h3>
<p>JPEG File Interchange Format, Version 1.01 (ISO DIS 10918-1, JPEG JFIF). The specification is located at <a class="bare" href="http://www.w3.org/Graphics/JPEG/jfif.txt">http://www.w3.org/Graphics/JPEG/jfif.txt</a>.</p>
</section><!-- 6.3 -->

<section id="6.4">
<h3><a href="#6.4">6.4</a> TIFF</h3>
<p><a class="bare" href="http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf">http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf</a></p>
</section><!-- 6.4 -->

<section id="6.5">
<h3><a href="#6.5">6.5</a> G4</h3>
<p>ITU-T (CCITT) T.6. Facsimile Coding Schemes and Coding Control Functions for Group 4 Facsimile Apparatus. <a class="bare" href="https://www.itu.int/rec/T-REC-T.6-198811-I/en">https://www.itu.int/rec/T-REC-T.6-198811-I/en</a></p>

</section><!-- 6.5 -->

<section id="6.6">
<h3><a href="#6.6">6.6</a> UTF-8</h3>
<p>All text in DjVu files is Unicode-encoded using the UTF-8 encoding. <a class="bare" href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf">http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf</a></p>
</section><!-- 6.6 -->

<section id="6.7">
<h3><a href="#6.7">6.7</a> DjVuLibre</h3>
<p>An open-source reference implementation of this file format specification is available at <a class="bare" href="http://sourceforge.net/projects/djvu/">http://sourceforge.net/projects/djvu/</a>. Throughout this specification, there are numerous references to source files in this implementation.</p>
</section><!-- 6.7 -->
</section><!-- 6 -->

<section id="7">
<h2><a href="#7">7</a> Component pieces (IFF chunks) of DjVu documents and images <small>[<a href="#">top</a>]</small></h2>

<p>This section describes the DjVu file format at a middle level. This includes types of chunks which can go into various types of documents but not a detailed layout of the contents of those chunks.</p>
<p>DjVu documents are IFF85 files (see <a href="#6.2">Reference 2</a> for details). The IFF85 structure provides a hierarchy of containers which hold various types of information in a DjVu file. The containers are called “chunks”. How the chunk is used (what it holds) can be determined by its “chunk type” or “chunk ID”. For example, the list of files contained in a multi-page document is held in the <span class="ck">DIRM</span> (“directory”) chunk; annotations are held in a <span class="ck">ANTz</span> chunk.</p>
<p><span class="ck">FORM</span> chunks are composite (contain other chunks). Their specific use is exposed by a secondary chunk ID. For example, a single page consists of several different chunks all contained within a single <span class="ck">FORM:DJVU</span> chunk. A multi-page document consists of several pages (and other chunks) all contained in a <span class="ck">FORM:DJVM</span> chunk.</p>
<p>This section discusses the various kinds of DjVu documents and the corresponding chunks of which they consist.</p>

<section id="7.1">
<h3><a href="#7.1">7.1</a> Single-page documents</h3>

<p>A single-page document is composed of a single <span class="ck">FORM:DVJU</span> composite chunk. This composite chunk always begins with one <span class="ck">INFO</span> chunk describing the image size, resolution and related information (see §<a href="#8.3.11">8.3.11</a>). The document contains exactly one DjVu image, whose content varies as described below.</p>

<section id="7.1.1">
<h4><a href="#7.1.1">7.1.1</a> Photo DjVu image</h4>
<p>Photo DjVu image files are best used for encoding photographic images in colors or in shades of gray. The data compression model relies on the IW44 wavelet representation. This format is designed such that the IW44 decoder is able to quickly perform progressive rendering of any image segment using only a small amount of memory. One or more additional <span class="ck">BG44</span> chunks contain the image data encoded with the IW44 representation. The image size specified in the <span class="ck">INFO</span> chunk and the image size specified in the IW44 data must be equal.</p>
</section><!-- 7.1.1 -->

<section id="7.1.2">
<h4><a href="#7.1.2">7.1.2</a> Bi-level DjVu image</h4>
<p>Bi-level DjVu image files are used to compress black and white images representing text and simple drawings. The JB2 data compression model uses the soft pattern-matching technique, which essentially consists of encoding each character by describing how it differs from a well-chosen already-encoded character. A <span class="ck">Sjbz</span> chunk contains the bi-level data encoded with the JB2 representation (see <a href="#11">Appendix 2</a>). The image size specified in the <span class="ck">INFO</span> chunk and the image size specified in the JB2 data must be equal.</p>
</section><!-- 7.1.2 -->

<section id="7.1.3">
<h4><a href="#7.1.3">7.1.3</a> Compound DjVu image</h4>
<p>Compound DjVu image files are an extremely efficient way to compress high-resolution compound document images containing both images and text, such as a page of a magazine. Compound DjVu files represent the document image using two layers. The <i>background layer</i> is used for encoding the pictures and the paper texture.</p>
<p>The <i>foreground layer</i> is used for encoding the text and the drawings. Additional chunks hold the components of either the foreground or the background layers.</p>
<p>The main component of the foreground layer is a bi-level image named the <i>foreground mask</i>. The pixel size of the foreground mask is equal to the size of the DjVu image. It contains a black-on-white representation of the text and the drawings. This image is encoded by a <span class="ck">Sjbz</span> chunk using the JB2 representation. There may also be a companion chunk <span class="ck">Djbz</span> containing a <i>shape dictionary</i> that defines bi-level shapes referenced by the <span class="ck">Sjbz</span> chunk.</p>

<section id="7.1.3.1">
<h5><a href="#7.1.3.1">7.1.3.1</a> Foreground encoding</h5>
<p>The foreground colors can be encoded according to two models:</p>
<ul>
<li>Using a small color image, the <i>foreground color image</i>, encoded as a single <span class="ck">FG44</span> chunk using the IW44 representation (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/IW44Image.h">IW44Image.h</a>).</li>
<li>By specifying one solid color per object described by the JB2-encoded mask. These <i>JB2 colors</i> are color-quantized and stored in a single <span class="ck">FGbz</span> chunk (see §<a href="#6.3.10">6.3.10</a>). Such compound DjVu images are rendered by painting each foreground object on top of the background color image using the solid color specified by the <span class="ck">FGbz</span> chunk.</li>
</ul>
</section><!-- 7.1.3.1 -->

<section id="7.1.3.2">
<h5><a href="#7.1.3.2">7.1.3.2</a> Background encoding</h5>
<p>The background layer is a color image, the <i>background color image</i>, encoded by an arbitrary number of <span class="ck">BG44</span> chunks containing successive IW44 refinements (see <a href="#10">Appendix 1</a>). The size of this image is computed by rounding up the quotient of the mask size by an integer sub-sampling factor ranging from 1 to 12. Most compound DjVu images use a background sub-sampling factor equal to 3. Smaller sub-sampling factors are adequate for images with a very rich paper texture. Larger sub-sampling factors are adequate for images containing no pictures.</p>
<p>There are no ordering or interleaving constraints on these chunks except that (a) the <span class="ck">INFO</span> chunk must appear first, and (b) the successive <span class="ck">BG44</span> refinements must appear with their natural order. The chunk order simply affects the progressive rendering of DjVu images in a web browser.</p>
</section><!-- 7.1.3.2 -->

<section id="7.1.3.3">
<h5><a href="#7.1.3.3">7.1.3.3</a> Alternative encodings</h5>
<p>Besides the JB2 and IW44 encoding schemes, the DjVu format supports alternative encdoding methods for its components.</p>
<p>The foreground mask may be represented by a single <span class="ck">Smmr</span> chunk instead of <span class="ck">Sjbz</span>. The <span class="ck">Smmr</span> chunk contains a bi-level image encoded with the Fax-G4/MMR method. Although the resulting files are typically six times larger, this capability can be useful when DjVu is used as a front-end for fax machines and scanners with embedded Fax-G4/MMR capabilities.</p>
<p>The background color image may be represented by a single <span class="ck">BGjp</span> chunk instead of several <span class="ck">BG44</span> chunks. The <span class="ck">BGjp</span> chunk contains a JPEG-encoded color image (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/JPEGDecoder.cpp">JPEGDecoder.cpp</a>). The resulting files are significantly larger and lack the progressivity of the usual DjVu files. This is useful because some scanners have embedded JPEG capabilities.</p>
<p>The foreground color image may be represented by a single <span class="ck">FGjp</span> chunk instead of a single <span class="ck">FG44</span> chunk. This is useful because some scanners have embedded JPEG capabilities.</p>
</section><!-- 7.1.3.3 -->

<section id="7.1.3.4">
<h5><a href="#7.1.3.4">7.1.3.4</a> Annotations and textual information</h5>
<p>All types of DjVu images may contain annotation chunks. Annotation chunks are used to describe hyperlinks, to specify more viewer settings (page background, initial zoom, etc.), and to hold metadata information. Annotations are contained in <span class="ck">ANTa</span> or <span class="ck">ANTz</span> chunks.</p>
<p>All types of DjVu image files may also contain a computer-readable description of the text appearing on the page. This information is contained in either a <span class="ck">TXTa</span> chunk or a <span class="ck">TXTz</span> chunk.</p>
</section><!-- 7.1.3.4 -->
</section><!-- 7.1.3 -->
</section><!-- 7.1 -->

<section id="7.2">
<h3><a href="#7.2">7.2</a> Multi-page documents</h3>
<p>A multi-page document is composed of a <span class="ck">FORM:DJVM</span> whose first chunk is a <span class="ck">DIRM</span> chunk containing the <i>document directory</i>. This directory lists all component files composing the given document, helps to access every component file and identifies the pages of the document.</p>
<p>In a <i>bundled</i> multi-page file, the component files are stored immediately after the <span class="ck">DIRM</span> chunk, within the <span class="ck">FORM:DJVM</span> composite chunk.</p>
<p>In an <i>indirect</i> multi-page file, the component files are stored in different files whose URLs are composed using information stored in the <span class="ck">DIRM</span> chunk.</p>

<section id="7.2.1">
<h4><a href="#7.2.1">7.2.1</a> Component files</h4>
<p>A multi-page DjVu document necessarily references other <span class="ck">FORM</span> (composite) chunks. Specifically:</p>
<ul>
<li>Each page is a single-page document (<span class="ck">FORM:DJVU</span> chunk).</li>
<li>Embedded thumbnails (if any) are contained in one or more <span class="ck">FORM:THUM</span> chunks.</li>
<li>Shared annotations (if any) and shape dictionaries (if any) are contained in one or more <span class="ck">FORM:DJVI</span> chunks.</li>
</ul>
<p>Each of these composite chunks (<span class="ck">FORM:DJVU</span>, <span class="ck">FORM:THUM</span>, <span class="ck">FORM:DJVI</span>) is a well-formed IFF byte stream in its own right and can be held in a separate disk file. In the context of a multi-page — either bundled or indirect — document, we refer to these composite chunks as <i>component files</i>.</p>
</section><!-- 7.2.1 -->

<section id="7.2.2">
<h4><a href="#7.2.2">7.2.2</a> Including shared information</h4>
<p>In many cases, efficiencies can be achieved by sharing JB2 shape definitions and/or annotations across pages. To facilitate this, any DjVu image file contained in a multi-page file may contain an <span class="ck">INCL</span> chunk containing the ID of a shared component file. The decoder processes the chunks contained in the shared component file as if the DjVu image file contained them. All relevant pages include this shared component file. Although they appear in several pages, these shared shapes are encoded only once in the document.</p>
<p>A shared component file is composed of a single <span class="ck">FORM:DJVI</span> potentially containing any information otherwise allowed in a DjVu image file (except for the <span class="ck">INFO</span> chunk of course).</p>
</section><!-- 7.2.2 -->
</section><!-- 7.2 -->
</section><!-- 7 -->

<section id="8">
<h2><a href="#8">8</a> Low-level chunk structure and definition <small>[<a href="#">top</a>]</small></h2>
<p>This section describes the DjVu file format at a low level. This includes the binary layout of the IFF85 wrapper and, of course, the layout of each contained chunk.</p>

<section id="8.1">
<h3><a href="#8.1">8.1</a> Header</h3>
<p>The first four bytes of a DjVu file are <span class="hex">0x41 0x54 0x26 0x54</span>. This preamble is not part of the EA IFF85 format, but it is required in order to identify DjVu files.</p>
</section><!-- 8.1 -->

<section id="8.2">
<h3><a href="#8.2">8.2</a> DjVu file structure</h3>

<section id="8.2.1">
<h4><a href="#8.2.1">8.2.1</a> IFF wrapper</h4>
<p>An IFF file consists of a number of chunks. Each chunk is laid out in three fields:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="array of four bytes">BYTE[4]</span></td>
  <td>Chunk ID. Describes the use of the chunk. The strings that identify the types of chunks used in DjVu are listed below.</td>
</tr>
<tr>
  <td><span class="ty" title="32-bit unsigned integer, most significant byte first">BE32</span></td>
  <td>The length of the data.</td>
</tr>
<tr>
  <td><span class="ty" title="variable-length array of bytes">BYTE[]</span></td>
  <td>The contained data.</td>
</tr>
</table>
<p>A chunk whose type is not recognized by the application is to be ignored. In the IFF format, chunks may be nested: a chunk may contain other chunks as part of its data. In the DjVu format, there is only one chunk at the outermost nesting level, a <span class="ck">FORM</span> chunk. All other chunks appear within the <span class="ck">FORM</span> chunk, sequentially, with no nesting.<sup>[<a id="note-8.2.1-1" href="./spec-comments.html#8.2.1-1">1</a>]</sup></p>
<p>Example:</p>
<table>
<thead>
<tr>
  <th>Offset</th>
  <th>Bytes</th>
  <th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
  <td><span class="hex">00000000</span></td>
  <td><span class="hex">41 54 26 54</span></td>
  <td>"AT&amp;T"; magic described in §<a href="#8.1">8.1</a>.</td>
</tr>
<tr>
  <td><span class="hex">00000004</span></td>
  <td><span class="hex">46 4f 52 4d</span></td>
  <td>"FORM"; chunk ID = <span class="ck">FORM</span></td>
</tr>
<tr>
  <td><span class="hex">00000008</span></td>
  <td><span class="hex">00 00 68 a6</span></td>
  <td><span class="hex">0xa668</span> = 26970; length of this <span class="ck">FORM</span> chunk</td>
</tr>
<tr>
  <td><span class="hex">0000000B</span></td>
  <td><span class="hex">44 4a 56 55</span></td>
  <td>"DJVU"; first four bytes of contained data. Since this is a <span class="ck">FORM</span> chunk, this starts with the sub-identifier. This is a <span class="ck">FORM:DJVU</span> chunk, a single-page document.</td>
</tr>
</tbody>
</table>
</section><!-- 8.2.1 -->

<section id="8.2.2">
<h4><a href="#8.2.2">8.2.2</a> Chunk summary</h4>
<p>The chunks used in the DjVu file format are summarized in Table 1.</p>
<table class="hoist">
<caption>Table 1: chunk summary</caption>
<thead>
<tr>
  <th>Chunk ID</th>
  <th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
  <td><span class="ck">FORM</span></td>
  <td>The composite chunk. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary identifier. Such chunks are referred to as <span class="ck">FORM:XXXX</span> where <span class="ck">XXXX</span> stands for the secondary identifier.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVM</span></td>
  <td>A multi-page DjVu document. Composite chunk that contains the <span class="ck">DIRM</span> chunk, possible shared/included chunks and subsequent <span class="ck">FORM:DJVU</span> chunks which make up a multi-page document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVU</span></td>
  <td>A DjVu page/single-page DjVu document. Composite chunk that contains the chunks that make up a page in a DjVu document.</td>
</tr>
<tr>
  <td><span class="ck">FORM:DJVI</span></td>
  <td>A “shared” DjVu file which is included via the <span class="ck">INCL</span> chunk. Shared annotations, shared shape dictionary.</td>
</tr>
<tr>
  <td><span class="ck">FORM:THUM</span></td>
  <td>Composite chunk that contains the <span class="ck">TH44</span> chunks that are the embedded thumbnails.</td>
</tr>
<tr>
  <td><span class="ck">DIRM</span></td>
  <td>Page name information for multi-page documents.</td>
</tr>
<tr>
  <td><span class="ck">NAVM</span></td>
  <td>Bookmark information.</td>
</tr>
<tr>
  <td><span class="ck">ANTa</span>, <span class="ck">ANTz</span></td>
  <td>Annotations, including both initial view settings and overlaid hyperlinks, text boxes, etc.</td>
</tr>
<tr>
  <td><span class="ck">TXTa</span>, <span class="ck">TXTz</span></td>
  <td>Unicode text and layout information.</td>
</tr>
<tr>
  <td><span class="ck">Djbz</span></td>
  <td>Shared shape table.</td>
</tr>
<tr>
  <td><span class="ck">Sjbz</span></td>
  <td>BZZ-compressed JB2 bitonal data used to store mask.</td>
</tr>
<tr>
  <td><span class="ck">FG44</span></td>
  <td>IW44 data used to store foreground.</td>
</tr>
<tr>
  <td><span class="ck">BG44</span></td>
  <td>IW44 data used to store background.</td>
</tr>
<tr>
  <td><span class="ck">TH44</span></td>
  <td>IW44 data used to store embedded thumbnail images.</td>
</tr>
<tr>
  <td><span class="ck">WMRM</span></td>
  <td>JB2 data required to remove a watermark.<sup>[<a id="note-8.2.2-1" href="./spec-comments.html#8.2.2-1">1</a>]</sup></td>
</tr>
<tr>
  <td><span class="ck">FGbz</span></td>
  <td>Color JB2 data. Provides a color for each [blit or shape?] in the corresponding <span class="ck">Sjbz</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">INFO</span></td>
  <td>Information about a DjVu page.</td>
</tr>
<tr>
  <td><span class="ck">INCL</span></td>
  <td>The ID of an included <span class="ck">FORM:DJVI</span> chunk.</td>
</tr>
<tr>
  <td><span class="ck">BGjp</span></td>
  <td>JPEG-encoded background.</td>
</tr>
<tr>
  <td><span class="ck">FGjp</span></td>
  <td>JPEG-encoded foreground.</td>
</tr>
<tr>
  <td><span class="ck">Smmr</span></td>
  <td>G4-encoded mask.</td>
</tr>
</tbody>
</table>
</section><!-- 8.2.2 -->
</section><!-- 8.2 -->

<section id="8.3">
<h3><a href="#8.3">8.3</a> IFF chunk types</h3>

<section id="8.3.1">
<h4><a href="#8.3.1">8.3.1</a> Container chunk: <span class="ck">FORM</span></h4>
<p>The <span class="ck">FORM</span> chunk is used as a chunk container. The first four bytes of the <span class="ck">FORM</span> chunk are a secondary ID used to identify the contained chunks.</p>

<section id="8.3.1.1">
<h5><a href="#8.3.1.1">8.3.1.1</a> <span class="ck">FORM:DJVM</span></h5>
<p>As discussed in §<a href="#7.2">7.2</a>, a multi-page DjVu document is composed of a single (composite) <span class="ck">FORM:DJVM</span> chunk. The first nested chunk is always a <span class="ck">DIRM</span> chunk containing the document directory (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/DjVmDir.cpp">DjVmDir.h</a>), which represents the list of the component files that make up the document. An optional <span class="ck">NAVM</span> chunk, which describes the outline of the document, may follow the <span class="ck">DIRM</span> chunk.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
  <span class="ck">FORM:DJVU</span> [7869 bytes] <span class="filename">p0002.djvu</span>
</pre>
</section><!-- 8.3.1.1 -->

<section id="8.3.1.2">
<h5><a href="#8.3.1.2">8.3.1.2</a> <span class="ck">FORM:DJVU</span></h5>
<p>As discussed in §<a href="#7.1">7.1</a>, a single page in a DjVu document is contained in a single (composite) <span class="ck">FORM:DJVU</span> chunk. The nested first chunk must be the <span class="ck">INFO</span> chunk. The chunks after the <span class="ck">INFO</span> chunk may occur in any order, although the order of the <span class="ck">BG44</span> chunks, if there is more than one, is significant.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVU</span> [26790 bytes]
  <span class="ck">INFO</span> [10 bytes] 2202 × 967, version 26, 300 dpi, gamma = 2.2
  <span class="ck">Sjbz</span> [13133 bytes] JB2 bi-level data
  <span class="ck">FG44</span> [185 bytes] IW44 data #1, 76 slices, version 1.2 (color), 184 × 81
  <span class="ck">BG44</span> [935 bytes] IW44 data #1, 74 slices, version 1.2 (color), 734 × 323
  <span class="ck">BG44</span> [1672 bytes] IW44 data #2, 10 slices
  <span class="ck">BG44</span> [815 bytes] IW44 data #3, 4 slices
  <span class="ck">BG44</span> [9976 bytes] IW44 data #4, 9 slices
</pre>
</section><!-- 8.3.1.2 -->

<section id="8.3.1.3">
<h5><a href="#8.3.1.3">8.3.1.3</a> <span class="ck">FORM:DJVI</span></h5>
<p>Multi-page DjVu documents can share information between pages by nesting a chunk inside a <span class="ck">FORM:DJVI</span> chunk (which is itself held inside the <span class="ck">FORM:DJVM</span> chunk) and referencing the contained chunk from within a page. Individual pages reference the shared chunks via the <span class="ck">INCL</span> chunk.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [126475 bytes]
  <span class="ck">DIRM</span> [59 bytes] Document directory (bundled, 3 files, 2 pages)
  <strong><span class="ck">FORM:DJVI</span> [3493 bytes] <span class="filename">dict0002.iff</span></strong>
    <strong><span class="ck">Djbz</span> [3481 bytes] JB2 shared dictionary</strong>
  <span class="ck">FORM:DJVU</span> [115016 bytes] <span class="filename">p0001.djvu</span>
    <span class="ck">INFO</span> [10 bytes] 2539 × 3295, version 25, 300 dpi, gamma = 2.2
    <strong><span class="ck">INCL</span> [12 bytes] Indirection chunk → <span class="filename">dict0002.iff</span></strong>
    <span class="ck">Sjbz</span> [70497 bytes] JB2 bi-level data
</pre>
</section><!-- 8.3.1.3 -->

<section id="8.3.1.4">
<h5><a href="#8.3.1.4">8.3.1.4</a> <span class="ck">FORM:THUM</span></h5>
<p>Pre-rendered thumbnails may be included. This allows very large documents to render thumbnails of pages without downloading and decoding them. <span class="ck">FORM:THUM</span> chunks contain several <span class="ck">TH44</span> chunks. Each of these chunks contains the thumbnails of the pages that follow.</p>
<p>Example:</p>
<pre style="overflow:auto">
<span class="ck">FORM:DJVM</span> [2272012 bytes]
  <span class="ck">DIRM</span> [108 bytes] Document directory (bundled, 7 files, 4 pages)
  <span class="ck">FORM:THUM</span> [5960 bytes] <span class="filename">p0001.thumb</span>
    <span class="ck">TH44</span> [5984 bytes] Thumbnail icon for page 1
  <span class="ck">FORM:DJVU</span> [1413380 bytes] <span class=filename">p0001.djvu</span>
    <span class="ck">INFO</span> [10 bytes] 4728 × 6300, version 25, 600 dpi, gamma = 2.2
    …
  <span class="ck">FORM:THUM</span> [12148 bytes] <span class="filename">p0004.thumb</span>
    <span class="ck">TH44</span> [3418 bytes] Thumbnail icon for page 2
    <span class="ck">TH44</span> [4150 bytes] Thumbnail icon for page 3
    <span class="ck">TH44</span> [4552 bytes] Thumbnail icon for page 4
  <span class="ck">FORM:DJVU</span> [777858 bytes] <span class="filename">p0002.djvu</span>
    …
</pre>
</section><!-- 8.3.1.4 -->
</section><!-- 8.3.1 -->

<section id="8.3.2">
<h4><a href="#8.3.2">8.3.2</a> Directory chunk: <span class="ck">DIRM</span></h4>
<p>As described in §<a href="#7.2">7.2</a>, a multi-page document will contain “component files” such as individual pages (<span class="ck">FORM:DJVU</span>) or shared annotations (<span class="ck">FORM:DJVI</span>).</p>
<p>The first contained chunk in a <span class="ck">FORM:DJVM</span> composite chunk is the <span class="ck">DIRM</span> chunk containing the <i>document directory</i>. It contains information the decoder will need to access the component files (see §<a href="#7.2">7.2</a>).</p>

<section id="8.3.2.1">
<h5><a href="#8.3.2.1">8.3.2.1</a> Unencoded data</h5>
<p>The first part of the <span class="ck">DIRM</span> chunk is unencoded:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td><p>Bit 7 (the MSB) is the <i>bundled</i> flag: 1 for bundled, 0 for indirect.</p>
  <p>Bits 6 through 0 are the version, currently 1.</p></td>
</tr>
<tr>
  <td><span class="ty" title="16-bit unsigned integer, most significant byte first">BE16</span></td>
  <td>Number of component files.</td>
</tr>
<tr>
  <td><span class="ty" title="variable-length array of 32-bit unsigned integers, most significant byte first">BE32[]</span></td>
  <td><p>When the document is a bundled document (i.e.&nbsp;the flag <var>bundled</var> is set), the header above is followed by the offsets of each of the component files within the <span class="ck">FORM:DJVM</span>. These offsets allow for random component file access.</p>
  <p>When the document is indirect, these offsets are omitted.</p></td>
</tr>
</table>
</section><!-- 8.3.2.1 -->

<section id="8.3.2.2">
<h5><a href="#8.3.2.2">8.3.2.2</a> BZZ-encoded data</h5>
<p>The rest of the chunk is entirely compressed with the BZZ general-purpose compressor. We describe now the data fed into (or retrieved from) the BZZ codec (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.cpp">BSByteStream.cpp</a> and <a href="#13">Appendix 4</a>).</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="variable-length array of 24-bit unsigned integers, most significant byte first">BE24[]</span></td>
  <td>Size of each component file. May be 0 for indirect documents.</td>
</tr>
<tr>
  <td><span class="ty" title="variable-length array of bytes">BYTE[]</span></td>
  <td>
    <p>Flag byte for each component file.</p>
    <ul>
      <li><span class="hex">0b</span>&langle;<var>hasname</var>&rangle;&langle;<var>hastitle</var>&rangle;<span class="hex">000000</span> for a file included by other files</li>
      <li><span class="hex">0b</span>&langle;<var>hasname</var>&rangle;&langle;<var>hastitle</var>&rangle;<span class="hex">000001</span> for a file representing a page</li>
      <li><span class="hex">0b</span>&langle;<var>hasname</var>&rangle;&langle;<var>hastitle</var>&rangle;<span class="hex">000010</span> for a file containing thumbnails</li>
    </ul>
    <p>Flag <var>hasname</var> is set when the name of the file is different from the file ID. Flag <var>hastitle</var> is set when the title of the file is different from the file ID. These flags are used to avoid encoding the same string three times.</p>
    <p>Note: in practice, the <var>hasname</var> and <var>hastitle</var> bits are poorly tested and not used.</p>
  </td>
</tr>
<tr>
  <td><span class="ty" title="variable-length array of null-terminated UTF-8 strings">ZSTR[]</span></td>
  <td>There are one to three zero-terminated strings per component file. The first string contains the ID of the component file. If <var>hasname</var> is set, then there is a second string which contains the name of the component file (in the case of an indirect file, this is the disk filename). If <var>hastitle</var> is set, then there is a third string which contains the name of the component (for display — for example, alternate page numberings in the Foreword or Preface).</td>
</tr>
</table>
<p>Examples:</p>
<table>
<thead>
<tr>
  <th>Bytes</th>
  <th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
  <th colspan="2">unencoded portion</th>
</tr>
<tr>
  <td><span class="hex">81</span></td>
  <td>bundled document, version 1</td>
</tr>
<tr>
  <td><span class="hex">00 03</span></td>
  <td>3 files</td>
</tr>
<tr>
  <td><pre class="hex">00 00 00 54
00 00 0e 02
00 01 cf 52</pre>
  </td>
  <td>file offsets: 84, 3586, 118610</td>
</tr>
<tr>
  <td></td>
</tr>
<tr>
  <th colspan="2">encoded portion (as passed to encoder)</th>
</tr>
<tr>
  <td><pre class="hex">00 0d ad
01 c1 50
00 1e c5</pre>
  </td>
  <td>file sizes: 3501, 115024, 7877</td>
</tr>
<tr>
  <td><pre class="hex">00
01
01</pre>
  </td>
  <td>flag bytes: included file, <var>hasname</var> = 0, <var>hastitle</var> = 0; page file, <var>hasname</var> = 0, <var>hastitle</var> = 0; page file, <var>hasname</var> = 0, <var>hastitle</var> = 0</td>
</tr>
<tr>
  <td><pre class="hex">64 69 63 74 30 30 30 32 2e 69 66 66 00
70 30 30 30 31 2e 64 6a 76 75 00
70 30 30 30 32 2e 64 6a 76 75 00</pre>
  </td>
  <td>file IDs: <span class="filename">dict0002.iff</span>, <span class="filename">p0001.djvu</span>, <span class="filename">p0002.djvu</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
  <th>Bytes</th>
  <th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
  <th colspan="2">unencoded portion</th>
</tr>
<tr>
  <td><span class="hex">01</span></td>
  <td>indirect document, version 1</td>
</tr>
<tr>
  <td><span class="hex">00 03</span></td>
  <td>3 files</td>
</tr>
<tr>
  <th colspan="2">encoded portion (as passed to encoder)</th>
</tr>
<tr>
  <td><pre class="hex">00 0d ad
01 c1 50
00 1e c5</pre>
  </td>
  <td>file sizes: 3501, 115024, 7877</td>
</tr>
<tr>
  <td><pre>00
01
01</pre>
  </td>
  <td>flag bytes: included file, <var>hasname</var> = 0, <var>hastitle</var> = 0; page file, <var>hasname</var> = 0, <var>hastitle</var> = 0; page file, <var>hasname</var> = 0, <var>hastitle</var> = 0</td>
</tr>
<tr>
  <td><pre>64 69 63 74 30 30 30 32 2e 69 66 66 00
70 30 30 30 31 2e 64 6a 76 75 00
70 30 30 30 32 2e 64 6a 76 75 00</pre>
  </td>
  <td>file IDs: <span class="filename">dict0002.iff</span>, <span class="filename">p0001.djvu</span>, <span class="filename">p0002.djvu</span></td>
</tr>
</tbody>
</table>
</section><!-- 8.3.2.2 -->
</section><!-- 8.3.2 -->

<section id="8.3.3">
<h4><a href="#8.3.3">8.3.3</a> Document outline chunk: <span class="ck">NAVM</span></h4>
<p>The <span class="ck">NAVM</span> chunk contains bookmarks which describe an outline of the document. The intent is to allow content authors to create an electronic table of contents which gives users rapid access to various parts of the document.</p>
<p>This chunk is optional, but, if present, must immediately follow the <span class="ck">DIRM</span> chunk.</p>
<p>The entire chunk is BZZ-encoded and starts with a single field specifying the total number of bookmark records:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="16-bit unsigned integer, most significant byte first">BE16</span></td>
  <td>The total number of bookmarks in the document.</td>
</tr>
</table>
<p>And then the individual bookmark records, nested as necessary:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>The number of immediate child bookmark records.</td>
</tr>
<tr>
  <td><span class="ty" title="24-bit unsigned integer, most significant byte first">BE24</span></td>
  <td>Size of the description text.</td>
</tr>
<tr>
  <td><span class="ty" title="UTF-8 string">STR</span></td>
  <td>The description text.</td>
</tr>
<tr>
  <td><span class="ty" title="24-bit unsigned integer, most significant byte first">BE24</span></td>
  <td>Size of the URL text.</td>
</tr>
<tr>
  <td><span class="ty" title="UTF-8 string">STR</span></td>
  <td>The URL text. This may (and typically does) use the syntax described for the URLs in the <span class="ck">ANTa</span> chunk (and similarly, is not URL-encoded).</td>
</tr>
</table>
<p>Example (as passed to the BZZ encoder):</p>
<p>Consider a small document outline as follows:</p>
<ol style="list-style-type:none">
<li>
  Table of Contents
  <ol style="list-style-type:none">
  <li>Introduction</li>
  <li>
    Datasheet
    <ol style="list-style-type:none">
    <li>For More Info (Online)</li>
    </ol>
  </li>
  </ol>
</li>
</ol>
<p>There is no hyperlink associated with the single root entry "Table of Contents". At a binary level, the chunk looks like this [before encoding]:
<table>
<thead>
<tr>
  <th>Offset</th>
  <th>Bytes</th>
  <th>Interpretation</th>
</tr>
</thead> 
<tbody>
<tr>
  <td><span class="hex">0012F06C</span></td>
  <td><span class="hex">00 04</span></td>
  <td>4 bookmarks</td>
</tr>
<tr>
  <th colspan="3">first record</th>
</tr>
<tr>
  <td><span class="hex">0012F06E</span></td>
  <td><span class="hex">02</span></td>
  <td>2 children</td>
</tr>
<tr>
  <td><span class="hex">0012F06F</span></td>
  <td><span class="hex">00 00 11</span></td>
  <td>17 bytes of description text</td>
</tr>
<tr>
  <td><span class="hex">0012F072</span></td>
  <td><pre class="hex">54 61 62 6c 65 20 6f 66 20 43 6f 6e 74 65 6e 74
73</pre></td>
  <td>description text: "Table of Contents"</td>
</tr>
<tr>
  <td><span class="hex">0012F083</span></td>
  <td><span class="hex">00 00 00</span></td>
  <td>0 bytes of URL text</td>
</tr>
<tr>
  <th colspan="3">second record</th>
</tr>
<tr>
  <td><span class="hex">0012F086</span></td>
  <td><span class="hex">00</span></td>
  <td>0 children</td>
</tr>
<tr>
  <td><span class="hex">0012F087</span></td>
  <td><span class="hex">00 00 0c</span></td>
  <td>12 bytes of description text</td>
</tr>
<tr>
  <td><span class="hex">0012F08A</span></td>
  <td><pre class="hex">49 9e 74 72 6f 64 75 63 74 69 6f 6e</pre></td>
  <td>description text: "Introduction"</td>
</tr>
<tr>
  <td><span class="hex">0012F096</span></td>
  <td><span class="hex">00 00 0b</span></td>
  <td>11 bytes of URL text</td>
</tr>
<tr>
  <td><span class="hex">0012F099</span></td>
  <td><span class="hex">23 70 30 30 30 31 2e 64 6a 76 75</span></td>
  <td>URL text: "#p0001.djvu"</td>
</tr>
<tr>
  <th colspan="3">third record</th>
</tr>
<tr>
  <td><span class="hex">0012F0A4</span></td>
  <td><span class="hex">01</span></td>
  <td>1 child</td>
</tr>
<tr>
  <td><span class="hex">0012F0A5</span></td>
  <td><span class="hex">00 00 09</span></td>
  <td>9 bytes of description text</td>
</tr>
<tr>
  <td><span class="hex">0012F0A8</span></td>
  <td><pre class="hex">44 61 74 61 73 68 65 65 74</pre></td>
  <td>description text: "Datasheet"</td>
</tr>
<tr>
  <td><span class="hex">0012F0B1</span></td>
  <td><span class="hex">00 00 0b</span></td>
  <td>11 bytes of URL text</td>
</tr>
<tr>
  <td><span class="hex">0012F0B4</span></td>
  <td><span class="hex">23 70 30 30 30 32 2e 64 6a 76 75</span></td>
  <td>URL text: "#p0002.djvu"</td>
</tr>
<tr>
  <th colspan="3">fourth record</th>
</tr>
<tr>
  <td><span class="hex">0012F0BF</span></td>
  <td><span class="hex">00</span></td>
  <td>0 children</td>
</tr>
<tr>
  <td><span class="hex">0012F0C0</span></td>
  <td><span class="hex">00 00 16</span></td>
  <td>22 bytes of description text</td>
</tr>
<tr>
  <td><span class="hex">0012F0C3</span></td>
  <td><pre class="hex">46 6f 72 20 4d 64 72 65 20 49 6e 66 6f 20 28 4f
6e 6c 69 6e 65 29</pre></td>
  <td>description text: "For More Info (Online)"</td>
</tr>
<tr>
  <td><span class="hex">0012F0D9</span></td>
  <td><span class="hex">00 00 19</span></td>
  <td>25 bytes of URL text</td>
</tr>
<tr>
  <td><span class="hex">0012F0DC</span></td>
  <td><pre class="hex">68 74 74 70 3a 2f 2f 77 77 77 2e 6c 69 7a 61 72
64 74 65 63 68 2e 63 6f 6d</pre></td>
  <td>URL text: "http://www.lizardtech.com"</td>
</tr>
</tbody>
</table>
</section><!-- 8.3.3 -->

<section id="8.3.4">
<h4><a href="#8.3.4">8.3.4</a> Annotation chunk: <span class="ck">ANTa</span>, <span class="ck">ANTz</span></h4>
<p>Annotations are contained in <span class="ck">ANTa</span> or <span class="ck">ANTz</span> chunks. The <span class="ck">ANTa</span> chunks contain the annotation in plain text. The <span class="ck">ANTz</span> chunks contain the same information compressed with the BZZ encoder (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.h">BSByteStream.h</a>).</p>
<p>The use of the <span class="ck">ANTa</span> chunk is discouraged.</p>
<p>Pages can share annotations using an <span class="ck">INCL</span> chunk as explained in §<a href="#7.2.2">7.2.2</a>. The complete annotation text is obtained by concatenating all annotation chunks present in the page. A restriction of the current reference library implementation limits the number of shared annotation files to one.<sup>[<a id="note-8.3.4-1" href="./spec-comments.html#8.3.4-1">1</a>]</sup></p>
<p>The syntax of the annotation text uses a simple parenthesized notation. All text is standard UTF-8.</p>

<section id="8.3.4.1">
<h5><a href="#8.3.4.1">8.3.4.1</a> Initial document view</h5>

<section id="8.3.4.1.1">
<h6><a href="#8.3.4.1.1">8.3.4.1.1</a> Background color</h6>
</section><!-- 8.3.4.1.1 -->

<section id="8.3.4.1.2">
<h6><a href="#8.3.4.1.2">8.3.4.1.2</a> Initial zoom</h6>
</section><!-- 8.3.4.1.2 -->

<section id="8.3.4.1.3">
<h6><a href="#8.3.4.1.3">8.3.4.1.3</a> Initial display level</h6>
</section><!-- 8.3.4.1.3 -->

<section id="8.3.4.1.4">
<h6><a href="#8.3.4.1.4">8.3.4.1.4</a> Alignment</h6>
</section><!-- 8.3.4.1.4 -->
</section><!-- 8.3.4.1 -->

<section id="8.3.4.2">
<h5><a href="#8.3.4.2">8.3.4.2</a> Maparea (overprinted annotations)</h5>

<section id="8.3.4.2.1">
<h6><a href="#8.3.4.2.1">8.3.4.2.1</a> <var>url</var></h6>
</section><!-- 8.3.4.2.1 -->

<section id="8.3.4.2.2">
<h6><a href="#8.3.4.2.2">8.3.4.2.2</a> <var>comment</var></h6>
</section><!-- 8.3.4.2.2 -->

<section id="8.3.4.2.3">
<h6><a href="#8.3.4.2.3">8.3.4.2.3</a> <var>area</var></h6>
</section><!-- 8.3.4.2.3 -->
</section><!-- 8.3.4.2 -->

</section><!-- 8.3.4 -->

<section id="8.3.5">
<h4><a href="#8.3.5">8.3.5</a> Text chunk: <span class="ck">TXTa</span>, <span class="ck">TXTz</span></h4>
<p>Text is contained in <span class="ck">TXTa</span> or <span class="ck">TXTz</span> chunks. The <span class="ck">TXTa</span> chunks contain the text unencoded. The <span class="ck">TXTz</span> chunks contain the same information compressed with the BZZ encoder (see <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.h">BSByteStream.h</a>).</p>
<p>The use of the <span class="ck">TXTa</span> chunk is discouraged.</p>
<p>The chunk begins with the UTF-8-encoded text of the page:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="24-bit unsigned integer, most significant byte first">BE24</span></td>
  <td>size of the text string in bytes</td>
</tr>
<tr>
  <td><span class="ty" title="UTF-8 string">STR</span></td>
  <td>UTF-8-encoded string</td>
</tr>
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>version (currently 1)</td>
</tr>
</table>
</section><!-- 8.3.5 -->

</section><!-- 8.3 -->
</section><!-- 8 -->

<section id="9">
<h2><a href="#9">9</a> DjVu in the raw (binary and IFF-level dumps) <small>[<a href="#">top</a>]</small></h2>
</section><!-- 9 -->

<section id="10">
<h2><a href="#10">10</a> Appendix 1: IW44 coding <small>[<a href="#">top</a>]</small></h2>
<p>This section describes the coding of chunks of type <span class="ck">BG44</span>, <span class="ck">FG44</span>, <span class="ck">PM44</span>, <span class="ck">BM44</span>, and <span class="ck">TH44</span>. Chunks of type <span class="ck">BG44</span>, <span class="ck">FG44</span>, and <span class="ck">TH44</span> may be color or grayscale chunks. Chunks of type <span class="ck">PM44</span> are color chunks. Chunks of type <span class="ck">BM44</span> are grayscale chunks. All of these color and grayscale chunk types have the same structure. The chunk consists of a chunk header followed by arithmetically-coded wavelet coefficient updates. The coefficients are organized in a hierarchical fashion.</p>

<section id="10.1">
<h3><a href="#10.1">10.1</a> Definitions</h3>
<dl>
<dt>Color component<dt>
<dd>Compound DjVu images and photo DjVu images contain color or grayscale image data. Color IW44 images contain color image data. Grayscale IW44 images contain grayscale image data. Color image data is coded using three color components, called <var>Y</var>, <var>Cb</var>, and <var>Cr</var>. These correspond to the usual YCbCr color space, adjusted to facilitate transformation to the RGB color space. Grayscale image data is coded using one color component, called <var>Y</var>. This corresponds to the grayscale intensity of the image.</dd>

<dt>Color layer</dt>
<dd>
A color layer is any of:
<ul>
<li>The foreground layer of a compound DjVu image, coded in one <span class="ck">FG44</span> chunk</li>
<li>The background layer of compound DjVu image, coded in one or more <span class="ck">BG44</span> chunks</li>
<li>The only layer of a photo DjVu image, coded in one or more <span class="ck">BG44</span> chunks</li>
<li>The only layer of a color IW44 image, coded in one or more <span class="ck">PM44</span> chunks</li>
<li>The only layer of a grayscale IW44 image, coded in one or more <span class="ck">BM44</span> chunks</li>
</ul>
</dd>

<dt>Color chunk</dt>
<dd>A color chunk is a chunk of type <span class="ck">BG44</span>, <span class="ck">FG44</span>, <span class="ck">PM44</span>, or <span class="ck">BM44</span>. A color chunk contains wavelet coefficient update information for one or three color components.</dd>

<dt>Block</dt>
<dd>A rectangular array of pixels of size 32 × 32 or less. The blocks are numbered starting in the lower left corner of the image. All blocks are 32 × 32 except possible those along the right edge or top edge; those blocks may be smaller if the image dimensions are not divisible by 32.</dd>

<dt>Block count</dt>
<dd>The number of blocks in the image, denoted by <var>NB</var>.</dd>

<dt>Wavelet block</dt>
<dd>The set of coefficients associated with one block of the image, in one color component. There are 1024 wavelet coefficients in a wavelet block, numbered 0 through 1023. The coefficients in a wavelet block have effects on the reconstruction of other blocks in the image, but for coding purposes they are considered to be localized within the block in which they are coded.</dd>

<dt>Bucket</dt>
<dd>A particular set of 16 wavelet coefficients within a wavelet block. A wavelet block consists of 64 buckets, numbered 0 through 63. Table 2 gives the correspondence between coefficients and buckets.</dd>

<dt>Band</dt>
<dd>A subset of wavelet coefficients for a given color component. There are 10 bands. The correspondence among band numbers, coefficient indices, and bucket coefficients is given by Table 2.</dd>

<dt>Cycle</dt>
<dd>Data for one color component consisting of coefficient updates for all coefficients, that is, for all 10 bands, starting with band 0. Within one band, only some coefficients are updated, but within a cycle, all coefficients are updated. The last cycle of a color component may have fewer than 10 bands.</dd>

<dt>Color band number</dt>
<dd>The current band number for a color component. Each color component’s color band number starts at 0, and increases by 1 at the end of selected slices until it reaches 9; then it is reset to 0.</dd>

<dt>Color band</dt>
<dd>A collection of update information for a subset of the coefficients of one color component of the image, consisting of updates of all the coefficients in the image whose indices within their respective blocks are those corresponding to the current color band’s color band number.</dd>

<dt>Slice</dt>
<dd>A slice is the highest-level subdivision of a color chunk. A slice contains data for one color band for each of the color components in a color layer, that is, for three color components for a color image, or for one color component for a grayscale image.</dd>

<dt>Block band</dt>
<dd>A collection of update information for a subset of the coefficients of one color component of a wavelet block, consisting of updates of the coefficients in the block whose indices are those corresponding to a given band.</dd>

<dt>Chrominance delay counter</dt>
<dd>An integer counter that indicates how many slices in a color layer contain a color band only for the <var>Y</var> color component, and not for the <var>Cb</var> and <var>Cr</var> color components. The chrominance delay counter is initially set to the value specified in the <span class="ck">INFO</span> chunk for the color layer, and decremented by 1 after each slice in the color layer until it reaches 0. See §<a href="#10.4.1.1">10.4.1.1</a>.</dd>

<dt>Step size table</dt>
<dd>A table that indicates the precision to which each coefficient in a color component is currently stored. There are three such tables for a given color layer, one for each color component. Each such table has 16 entries. Each entry specifies the current step size for 1, 4, 16, 64, or 256 different coefficient indices, according to Table 3.</dd>

</dl>
</section><!-- 10.1 -->

<section id="10.2">
<h3><a href="#10.2">10.2</a> Color chunks within a DjVu file</h3>
<p>There may be more than one <span class="ck">BG44</span>, <span class="ck">PM44</span>, or <span class="ck">BM44</span> chunk in a DjVu file. If there is more than one such color chunk, the coefficient updating is continuous across the chunks, and the data is taken from the chunks in the order in which they appear in the file. Nothing is reinitialized at the beginning of chunks after the first color chunk of these types, except for the low-level arithmetic coder. The probability estimates for the arithmetic coder are not reinitialized.</p>
<p>In a compound DjVu image file, in which both an <span class="ck">FG44</span> chunk and one or more <span class="ck">BG44</span> chunks appear in the same file, the coding of the foreground layer, using the <span class="ck">FG44</span> chunk, is independent of the coding of the background layer, using the <span class="ck">BG44</span> chunks.</p>
<p>Each color layer is coded using a Dubuc–Deslauriers–Lemire (4, 4) interpolative wavelet transform. Each layer of the image is transformed into a set of wavelet coefficients, one wavelet coefficient for each pixel in the original image. This transform is especially effective for coding images at high compression ratios.</p>
<p>The value of each coefficient is coded in a distributed fashion, through a number of cycles. Within one cycle, each coefficient is updated once (that is, in only one of the 10 bands), and receives approximately one additional bit of information. Specifically, from cycle to cycle the absolute value of a coefficient is first narrowed down by eliminating possible values for the most significant non-zero bit until the correct most significant non-zero bit is found. The sign is coded in the same cycle in which the most significant non-zero bit is found. Then in each subsequent cycle, one additional bit of the value is coded.</p>
</section><!-- 10.2 -->

<section id="10.3">
<h3><a href="#10.3">10.3</a> Color chunk data headers</h3>
<p>A color chunk begins with a data header consisting of 2 or 9 octets, as follows:</p>
<table class="hoist">
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>Serial number</td>
  <td>The serial number of the first chunk of a given chunk type is 0. Successive chunks are assigned consecutive serial numbers.</td>
</tr>
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>Number of slices</td>
  <td>The number of slices coded in the chunk.</td>
</tr>
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>Major version number and color type</td>
  <td>One octet containing two values, present only if the serial number is 0. The least significant seven bits designate the major version number of the standard being implemented by the decoder. For this version of the standard, the major version number is 1. The most significant bit is the color type bit. The color type bit is 0 if the chunk describes three color components. The color type bit is 1 if the chunk describes one color component.</td>
</tr>
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>Minor version number</td>
  <td>A one-octet unsigned integer, present only if the serial number is 0. This octet designates the minor version number of the standard being implemented by the decoder. For this version of the standard, the minor version number is 0.</td>
</tr>
<tr>
  <td><span class="ty" title="16-bit unsigned integer, most significant byte first">BE16</span></td>
  <td>Image width</td>
  <td>A two-octet unsigned integer, most significant octet first, present only if the serial number is 0. This field indicates the number of pixels in each row of the image described by the current chunk. The image width will be less than the width of the original image if the chunk describes a layer coded at lower resolution than the original image. For a <span class="ck">BG44</span> or <span class="ck">FG44</span> chunk, if <var>W</var> is the width of the original image specified in the <span class="ck">INFO</span> chunk, and <var>w</var> is the width of the image described by the current chunk, then the allowable values of <var>w</var> are
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>2</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>3</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>4</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>5</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>6</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>7</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>8</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>9</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>10</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>11</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>, and
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>W</mi>
    <mi>/</mi>
    <mn>12</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>.
  For a <span class="ck">BM44</span> or <span class="ck">PM44</span> chunk, there are no restrictions on the image width.</td>
</tr>
<tr>
  <td><span class="ty" title="16-bit unsigned integer, most significant byte first">BE16</span></td>
  <td>Image height</td>
  <td>A two-octet unsigned integer, most significant octet first, present only if the serial number is 0. This field indicates the number of pixels in each column of the image described by the current chunk. The image height will be less than the height of the original image if the chunk describes a layer coded at lower resolution than the original image. For a <span class="ck">BG44</span> or <span class="ck">FG44</span> chunk, if <var>H</var> is the height of the original image specified in the <span class="ck">INFO</span> chunk, and <var>h</var> is the height of the image described by the current chunk, then the allowable values of <var>h</var> are
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>2</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>3</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>4</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>5</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>6</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>7</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>8</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>9</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>10</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>,
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>11</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>, and
<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mrow>
    <mo stretchy="false" form="prefix">⌈</mo>
    <mi>H</mi>
    <mi>/</mi>
    <mn>12</mn>
    <mo stretchy="false" form="postfix">⌉</mo>
  </mrow>
</math>.
  For a <span class="ck">BM44</span> or <span class="ck">PM44</span> chunk, there are no restrictions on the image height.</td>
</tr>
<tr>
  <td><span class="ty" title="single byte">BYTE</span></td>
  <td>Initial value of chrominance delay counter</td>
  <td>A one-octet unsigned integer, present only if the serial number is 0. Only the least significant seven bits are used. The most significant bit is ignored, but should be set to 1 by an encoder. This field specifies the initial value of the chrominance delay counter, used as described below.</td>
</tr>
</table>

</section><!-- 10.3 -->

<section id="10.4">
<h3><a href="#10.4">10.4</a> Color chunk data</h3>

<section id="10.4.1">
<h4><a href="#10.4.1">10.4.1</a> Hierarchical structure of a coded color layer</h4>
<p>The data coded in a color chunk consists of information needed to reconstruct wavelet coefficients. There are one or three color components; each color component has its own set of wavelet coefficients. Within a color component, there are 1024 wavelet coefficients for each 32 × 32 block of the image.</p>
<p>Within one layer (background or foreground for DjVu image, or the only layer for an IW44 image), coding is divided into a series of slices. All the slices may be coded in one chunk, or they may be separated into a number of chunks. The only difference it makes whether the slices are coded in one chunk or in several chunks is in the order of progressive rendering; the final reconstructed image will be the same. The number of slices in each chunk is specified in the color chunk data header. One slice contains refinement data for one color band for each color component. Within a color component, all coefficients in a slice are in the same band.</p>
<p>A color chunk describes the full image at the spatial resolution implied by the image width and image height fields in the data header of the first chunk of the same type as the current color chunk.</p>
<p>The sequence of color components within a slice is: first <var>Y</var>, then <var>Cb</var>, then <var>Cr</var>, although the <var>Cb</var> and <var>Cr</var> components are not present in a slice if the chunk describes grayscale data or if the chrominance delay counter is not equal to 0 at the time the slice is coded.</p>
<p>A color band is made of up coefficient updates for all blocks in the image, but only for coefficients that are in the currently active band for the color component. Each block’s set of updates within a color band is called a <i>block band</i>. The block bands are coded block by block, first from left to right within the bottom row, then by rows moving up the image, left to right within each row.</p>
<p>Within a block band, there are 16, 64, or 256 coefficient updates. The coefficients being updated are divided into buckets, each bucket containing 16 coefficients. Thus, a block band contains 1, 4, or 16 buckets. The buckets and coefficients being updated are determined by the color band number according to Table 2.</p>

<section id="10.4.1.1">
<h5><a href="#10.4.1.1">10.4.1.1</a> Band counting</h5>
<p>The header of the first color chunk contains an initial value for the chrominance delay counter. It may be 0 or a positive integer.</p>
<p>At the beginning of the first color chunk, the color band number for each of the three color components is set to 0.</p>
<p>At the beginning of each slice, the chrominance delay counter is tested. If the chrominance delay counter is 0, and if the slice describes color image data, then all three color components are present. If the chrominance delay counter is greater than 0, or if the chunk describes grayscale image data, only the <var>Y</var> color component is present for the slice.</p>
<p>At the end of a slice, the following actions take place:</p>
<ul>
<li>The color band number is increased by 1 for the <var>Y</var> component. If the new color band number exceeds 9, it is set to 0.</li>
<li>If the chrominance delay counter is 0, the color band numbers for the <var>Cb</var> and <var>Cr</var> components are increased by 1. If the new color band numbers exceed 9, they are set to 0. (Note: the color band numbers for the <var>Cb</var> and <var>Cr</var> components are always equal to each other.)</li>
<li>If the chrominance delay counter is greater than 0, it is decreased by 1.</li>
</ul>
<p>A color chunk ends when the number of slices specified in the color chunk header have been coded. At the beginning of each color chunk after the first for a given color layer, the chrominance delay counter and color band numbers retain the values they had at the end of the previous color chunk.</p>
</section><!-- 10.4.1.1 -->
</section><!-- 10.4.1 -->

<section id="10.4.2">
<h4><a href="#10.4.2">10.4.2</a> Quantization of coefficients</h4>
<p>At each point during the decoding process, each wavelet coefficient has been determined to a certain precision. The current value <var>a</var> of the coefficient is stored, and a current step size <var>S</var> is associated with the coefficient. The current step size for each coefficient is governed by a step size table. The index of the entry in the step size table that contains the step size for a given coefficient that contains the step size for a given coefficient is given in Table 3.</p>

</section><!-- 10.4.2 -->
</section><!-- 10.4 -->
</section><!-- 10 -->

<section id="11">
<h2><a href="#11">11</a> Appendix 2: JB2 coding <small>[<a href="#">top</a>]</small></h2>

<section id="11.1">
<h3><a href="#11.1">11.1</a> General considerations</h3>
<p>Selection layer coding is used in compound DjVu images. In such images, there are three layers. The foreground layer is coded in one <span class="ck">FG44</span> chunk, and is rendered as described in <a href="#10">Appendix 1</a>. The background layer is coded in one or more <span class="ck">BG44</span> chunks, and is rendered as described in Appendix 1. The selection layer is coded using one <span class="ck">Sjbz</span> chunk. Black pixels in the selection layer specify those pixels that are to be rendered using the foreground color. All other pixels are to be rendered using the background color.</p>
<p>Black-and-white coding is used in bi-level DjVu images. In such images, there are three layers. The foreground layer is black. The background layer is white. The selection layer is coded using one <span class="ck">Sjbz</span> chunk. The selection layer specifies those pixels that are to be rendered in black. All other pixels are to be rendered in white.</p>
<p>An <span class="ck">Sjbz</span> chunk contains a single arithmetically-coded data stream, coded using the Z&prime;-Coder (<a href="#12">Appendix 3</a>). All data, including headers and record types, is coded in this arithmetically-coded stream.</p>
</section><!-- 11.1 -->

<section id="11.2">
<h3><a href="#11.2">11.2</a> Arithmetic coding</h3>
<p>The arithmetically-coded data in an <span class="ck">Sjbz</span> chunk consists logically of records. The record types are listed in Table 6, and described in §<a href="#11.4">11.4</a>. The records consist of fields. The fields present for records of each record type are listed in Table 6. The fields within a record are coded in the order listed in Table 6 for records of that type. Details of the coding for each field appear in §<a href="#11.5">11.5</a>.</p>
<p>A field may contain one or more data elements. The data elements consist of flags, pixel colors, and integers. Because of the nature of arithmetic coding, the records, fields, and data elements are not of fixed sizes, and do not necessarily begin on bit boundaries within the data stream.</p>
<p>Flags are binary decisions, each coded using the Z&prime;-Coder with a particular context. There are two different contexts for flags, the eventual image refinement context and the offset type context.</p>
<p>Pixel colors are binary decisions, coded using the Z&prime;-Coder with a particular context. For pixel colors, there are 3072 different contexts. There are 1024 contexts used for direct coding of bitmaps; these correspond to the
<math>
  <mrow>
    <msup>
      <mn>2</mn>
      <mn>10</mn>
    </msup>
    <mo>=</mo>
    <mn>1024</mn>
  </mrow>
</math>
different combinations of values that the pixels in the direct coding template can assume. There are 2048 contexts used for refinement coding of bitmaps; these correspond to the
<math>
  <mrow>
    <msup>
      <mn>2</mn>
      <mn>11</mn>
    </msup>
    <mo>=</mo>
    <mn>2048</mn>
  </mrow>
</math>
different combinations of values that the pixels in the refinement coding template can assume.</p>
<p>Integers are coded using the multivalue extension to the Z&prime;-Coder, described below. There are 15 contexts for coding multivalued integers, as described in Table 7.</p>

<section id="11.2.1">
<h4><a href="#11.2.1">11.2.1</a> Initialization of the Z&prime;-Coder</h4>
<p>All Z&prime;-Coder contexts are initialized to the value 0. This applies both to contexts used to encode single-bit values, including pixel colors, and to contexts that are part of an integer context used by the multivalue extension to the Z&prime;-Coder.</p>
</section><!-- 11.2.1 -->

<section id="11.2.2">
<h4><a href="#11.2.2">11.2.2</a> The multivalue extension to the Z&prime;-Coder for coding of numeric data</h4>
<p>Quantities that can take on multiple values are coded as integers using the multivalue extension to the Z&prime;-Coder. This extension of the Z&prime;-Coder allows all data in the bit stream to be coded using the same coder, the Z&prime;-Coder. There are 15 integer contexts, specified in Table 7. A single integer context includes a number of binary contexts.</p>
<p>One integer context consists of a binary decision tree. See Figure 1 for an example of part of such a tree. The root node of the tree corresponds to the decision about the sign of the number <var>n</var> being decoded. Each of the two sub-trees under the root corresponds to a set of decisions that eventually identify a range in which <var>n</var> lies. The sub-trees under the nodes corresponding to identified ranges are complete binary trees that identify the exact value of <var>n</var>.</p>
<p>Each node of the binary decision tree for an integer context maintains its own binary probability estimation context for the Z&prime;-Coder. The trees for different integer contexts are completely independent. Thus each node of a tree contains probability information conditioned on a conditioning context. The conditioning context consists of both the type of value being coded (i.e., the selection of the integer context), and of the values of the decisions coded so far when encoding the current integer.</p>
</section><!-- 11.2.2 -->

<section id="11.2.3">
<h4><a href="#11.2.3">11.2.3</a> Record types</h4>
<table>
<caption>Table 6: record types and fields coded for each record type</caption>
<thead>
<tr>
  <th>Record type coded value</th>
  <th>Record type</th>
  <th>Fields coded</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0</td>
  <td>Start of image</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Image size</li>
      <li>Eventual image refinement flag</li>
    </ol>
  </td>
</tr>
<tr>
  <td>1</td>
  <td>New symbol, add to image and library</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>2</td>
  <td>New symbol, add to library only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
    </ol>
  </td>
</tr>
<tr>
  <td>3</td>
  <td>New symbol, add to image only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>4</td>
  <td>Matched symbol with refinement, add to image and library</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>5</td>
  <td>Matched symbol with refinement, add to library only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
    </ol>
  </td>
</tr>
<tr>
  <td>6</td>
  <td>Matched symbol with refinement, add to image only</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Relative symbol size</li>
      <li>Bitmap by refinement coding</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>7</td>
  <td>Matched symbol, copy to image without refinement</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Index of matching symbol in bitmap library</li>
      <li>Location relative to a previous symbol</li>
    </ol>
  </td>
</tr>
<tr>
  <td>8</td>
  <td>Non-symbol data</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Absolute symbol size</li>
      <li>Bitmap by direct coding</li>
      <li>Absolute location</li>
    </ol>
  </td>
</tr>
<tr>
  <td>9</td>
  <td>Shared dictionary or reset</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Shared dictionary size</li>
    </ol>
  </td>
</tr>
<tr>
  <td>10</td>
  <td>Comment</td>
  <td>
    <ol>
      <li>Record type</li>
      <li>Comment length</li>
      <li>Comment data</li>
    </ol>
  </td>
</tr>
<tr>
  <td>11</td>
  <td>End of data</td>
  <td>
    <ol>
      <li>Record type</li>
    </ol>
  </td>
</tr>
</tbody>
</table>
</section><!-- 11.2.3 -->

<section id="11.2.4">
<h4><a href="#11.2.4">11.2.4</a> Fields and contexts</h4>
<table>
<caption>Table 7: multivalued integer contexts for arithmetic coding</caption>
<thead>
<tr>
  <th>Context name</th>
  <th>Integer data coded using this context</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Record type</td>
  <td>Record type</td>
</tr>
<tr>
  <td>Image size</td>
  <td>Image height; image width</td>
</tr>
<tr>
  <td>Matching symbol index</td>
  <td>Index within the symbol library of the symbol matching the current symbol</td>
</tr>
<tr>
  <td>Symbol width</td>
  <td>Width of the current symbol in pixels</td>
</tr>
<tr>
  <td>Symbol height</td>
  <td>Height of the current symbol in pixels</td>
</tr>
<tr>
  <td>Symbol width difference</td>
  <td>Number of pixels that must be added to the width of the matching symbol to obtain the width of the current symbol</td>
</tr>
<tr>
  <td>Symbol height difference</td>
  <td>Number of pixels that must be added to the height of the matching symbol to obtain the height of the current symbol</td>
</tr>
<tr>
  <td>Symbol column number</td>
  <td>Column number of the absolute location of the left edge of the current symbol (leftmost column of the image is column number 1)</td>
</tr>
<tr>
  <td>Symbol row number</td>
  <td>Row number of the absolute location of the top edge of the current symbol (bottom row of the image is row number 1)</td>
</tr>
<tr>
  <td>Same line column offset</td>
  <td>Number of pixels that must be added to the column number of the right edge of the previous symbol on the current text line to obtain the column number of the left edge of the current symbol</td>
</tr>
<tr>
  <td>Same line row offset</td>
  <td>Number of pixels that must be added to the row number of the current baseline on the current text line to obtain the row number of the bottom edge of the current symbol</td>
</tr>
<tr>
  <td>New line column offset</td>
  <td>Number of pixels that must be added to the column number of the left edge of the first symbol on the current text line to obtain the column number of the left edge of the current symbol</td>
</tr>
<tr>
  <td>New line row offset</td>
  <td>Number of pixels that must be added to the row number of the bottom edge of the first symbol on the current text line to obtain the row number of the top edge of the current symbol</td>
</tr>
<tr>
  <td>Comment length</td>
  <td>The number of octets in the current comment</td>
</tr>
<tr>
  <td>Comment octet</td>
  <td>One octet in the current comment</td>
</tr>
<tr>
  <td>Dictionary size</td>
  <td>Number of shapes in the shared dictionary</td>
</tr>
</tbody>
</table>
</section><!-- 11.2.4 -->

<section id="11.2.5">
<h4><a href="#11.2.5">11.2.5</a> Coding phases</h4>
<figure>
<!-- TODO -->
<figcaption>
<p>Figure 1: Part of the coding tree for multivalue arithmetic coding. Each internal node represents one context with its own probability information, to be used by the Z&prime;-Coder. The square node at the root of the tree represents the Phase 1 decision, whether the integer <var>n</var> being coded is negative. The filled circles are the Phase 2 nodes, moving down the tree in ever-increasing ranges. The open circles represent Phase 3 decisions, traversing a complete binary sub-tree to reach the specific value of <var>n</var>. A decoded value of 0 indicates a left branch in this tree. A decoded value of 1 indicates a right branch.</p>
<p>This method allows high compression efficiency by allowing the coder to adapt to the statistics of the data. In effect, the binary probability information stored collectively in the nodes of the decision tree closely approximates the probability distribution of the underlying multivalued integer.</p>
<p>The allowable range of values for <var>n</var> is always specified. The smallest value that <var>n</var> could possibly take is denoted by <var>l</var>. The largest value that <var>n</var> could possibly take is denoted by <var>h</var>. When <var>l</var> and <var>h</var> are equal, <var>n</var> is equal to both of them, and no Z&prime;-Coder decoding is performed.</p>
<p>The decoder maintains a non-negative intermediate value <var>v</var>, defined as follows:
<math display="block">
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mrow>
      <mo stretchy="true" form="prefix">{</mo>
      <mtable>
        <mtr>
          <mtd>
            <mo stretchy="false" form="prefix">|</mo>
            <mi>n</mi>
            <mo stretchy="false" form="prefix">|</mo>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mo>≥</mo>
            <mn>0</mn>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo stretchy="false" form="prefix">|</mo>
              <mi>n</mi>
              <mo stretchy="false" form="prefix">|</mo>
            </mrow>
            <mo>−</mo>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mo>&lt;</mo>
            <mn>0</mn>
            <mi>.</mi>
          </mtd>
        </mtr>
      </mtable>
    </mrow>
  </mrow>
</math>
At the end of the process of decoding an integer, <var>v</var> is converted to <var>n</var>, the value of the decoded integer.</p>
</figcaption>
</figure>
<p>The value of an integer is coded by making a sequence of binary decisions, each one narrowing the set of values that the integer can possibly take. The decisions are based on traversing a binary decision tree to one of its leaves. Note: although the tree conceptually has a large number of nodes, it is possible in an implementation to allocate memory only for those nodes actually traversed. Decoding proceeds in four phases.</p>

<section id="11.2.5.1">
<h5><a href="#11.2.5.1">11.2.5.1</a> Phase 1</h5>
<p>Phase 1 determines the sign of <var>n</var>. A value of 0 returned by the Z&prime;-Coder means that
<math>
  <mrow>
    <mi>n</mi>
    <mo>&lt;</mo>
    <mn>0</mn>
  </mrow>
</math>.
A value of 1 returned by the Z&prime;-Coder means that
<math>
  <mrow>
    <mi>n</mi>
    <mo>≥</mo>
    <mn>0</mn>
  </mrow>
</math>.</p>
</section><!-- 11.2.5.1 -->

<section id="11.2.5.2">
<h5><a href="#11.2.5.2">11.2.5.2</a> Phase 2</h5>
<p>Phase 2 determines a range of possible values for <var>v</var>. The Z&prime;-Coder is invoked repeatedly to answer the question “Is the value of <var>v</var> in the range being tested?” The sequence of ranges tested is given in Table 8. A value of 0 returned by the Z&prime;-Coder means that <var>v</var> is not in the specified range, and the next range in the sequence must be tested. A value of 1 returned by the Z&prime;-Coder means that <var>v</var> is in the specified range, and decoding is to proceed to Phase 3.</p>
<table>
<caption>Table 8: sequence of ranges in which <var>v</var> may fall</caption>
<tr><td>&#8199;&#8199;&#8199;&#8199;&#8199;0</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;&#8199;1–2</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;&#8199;3–6</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;&#8199;7–14</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;15–30</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;31–62</td></tr>
<tr><td>&#8199;&#8199;&#8199;&#8199;63–126</td></tr>
<tr><td>&#8199;&#8199;&#8199;127–254</td></tr>
<tr><td>&#8199;&#8199;&#8199;255–510</td></tr>
<tr><td>&#8199;&#8199;&#8199;511–1022</td></tr>
<tr><td>&#8199;&#8199;1023–2046</td></tr>
<tr><td>&#8199;&#8199;2047–4094</td></tr>
<tr><td>&#8199;&#8199;4095–8190</td></tr>
<tr><td>&#8199;&#8199;8191–16382</td></tr>
<tr><td>&#8199;16383–32766</td></tr>
<tr><td>&#8199;32767–65534</td></tr>
<tr><td>&#8199;65535–131070</td></tr>
<tr><td>131071–262142</td></tr>
</table>
</section><!-- 11.2.5.2 -->

<section id="11.2.5.3">
<h5><a href="#11.2.5.3">11.2.5.3</a> Phase 3</h5>
<p>Phase 3 consists of determining the exact value of <var>v</var> within the range determined in Phase 2. If Phase 2 determined that
<math>
  <mrow>
    <mi>v</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>,
then Phase 3 is skipped. Otherwise, since the size of the range is a power of 2, the corresponding sub-tree is a complete binary tree. The sequence of coding decisions is based directly on traversing the binary tree. At each node, 0 returned by the Z&prime;-Coder means left branch (smaller values of <var>v</var>) and 1 means right branch (larger values of <var>v</var>. The bits returned by the Z&prime;-Coder during Phase 3 are the bits of <var>v</var>, most significant bit first.</p>
</section><!-- 11.2.5.3 -->

<section id="11.2.5.4">
<h5><a href="#11.2.5.4">11.2.5.4</a> Phase 4</h5>
<p>In Phase 4, the unsigned value <var>v</var> is converted to <var>n</var>, the signed value to be returned, as follows:
<math display="block">
  <mrow>
    <mi>n</mi>
    <mo>=</mo>
    <mrow>
      <mo stretchy="true" form="prefix">{</mo>
      <mtable>
        <mtr>
          <mtd>
            <mi>v</mi>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mrow>
              <mspace width="0.333em" />
              <mtext mathvariant="normal"> is non-negative, as determined in Phase 1;</mtext>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mo>−</mo>
            <mi>v</mi>
            <mo>−</mo>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext mathvariant="normal">if </mtext>
              <mspace width="0.333em" />
            </mrow>
            <mi>n</mi>
            <mrow>
              <mspace width="0.333em" />
              <mtext mathvariant="normal"> is negative.</mtext>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
    </mrow>
  </mrow>
</math></p>
<p>In any of the phases, if the input values of <var>l</var> and <var>h</var> (the range of allowable values) predetermine any decision, then the coding for that decision is not performed; the predetermined decision is assumed.</p>
<p>Each type of integer has its own set of binary contexts. Thus the probability information will reflect the underlying probability distribution of the particular type of integer. The Z&prime;-Coder probability state indices of all the binary nodes are initialized to 0.</p>
</section><!-- 11.2.5.4 -->
</section><!-- 11.2.5 -->
</section><!-- 11.2 -->

<section id="11.3">
<h3><a href="#11.3">11.3</a> Image reconstruction</h3>
<p>Records in an <span class="ck">Sjbz</span> chunk are interpreted in the order in which they appear. A "Start of data" record specifies the dimensions of the image. An "Image refinement data" record indicates […]<sup>[<a href="./spec-comments.html#11.3-1">1</a>]</sup>. An "End of data" record indicates the end of the <span class="ck">Sjbz</span> chunk. A "Comment" record contains uninterpreted data.</p>
<p>A record identified by any other record type describes one bitmap. The model used in DjVu for the selection layer is based on symbol-based coding. Bitmaps are placed into the reconstructed image as follows: The image is initially entirely white. When a bitmap is placed into the image, the pixels that are black in the current symbol become black at the appropriate position in the reconstructed image. Once a pixel in the reconstructed image becomes black, it remains black.</p>
<p>Because symbols in the document images are often similar to each other, it is often possible to obtain more efficient coding by making use of previously coded symbols. As symbols are decoded, their bitmaps may be placed into a symbol bitmap library. There is exactly one symbol bitmap library. Once a symbol has been placed into the symbol bitmap library, later records may cause copies of the symbol to be placed into the image, or may define a new bitmap by refining the bitmap in the library.</p>
<p>Depending on the record type, the symbol bitmap may be described by direct coding, by refinement coding, or by a copy operation. In direct coding, all pixels of the bitmap are coded directly, without reference to any other bitmap. In refinement coding, all pixels of the bitmap are also coded directly, but a bitmap in the library is used to make the coding more efficient. In a copy operation, the pixels of the bitmap are the same as the pixels of a bitmap in the library.</p>
<p>Depending on the record type, the bitmap may or may not be placed into the image. If the bitmap is placed into the image, then depending on the record type, it may be placed either at an absolute location or at a location relative to a previously placed bitmap.</p>
<p>Depending on the record type, the bitmap may or may not be placed into the symbol bitmap library. The first symbol placed into the library has index 0. Subsequent symbols are assigned consecutive integer indices.</p>
<p>The pixels of the reconstructed image are arranged in a rectangular coordinate system. For the pixel in the lower left corner of the image, the column number is 1 and the row number is 1. All coordinates refer to the pixels themselves, not to the edges between pixels.</p>
</section><!-- 11.3 -->

<section id="11.4">
<h3><a href="#11.4">11.4</a> Records</h3>
<p>Records in <span class="ck">Sjbz</span> chunks have the following interpretations.</p>

<section id="11.4.1">
<h4><a href="#11.4.1">11.4.1</a> Start of image</h4>
<p>This record is the first record in an <span class="ck">Sjbz</span> chunk. It specifies the dimensions of the image.</p>
</section><!-- 11.4.1 -->

<section id="11.4.2">
<h4><a href="#11.4.2">11.4.2</a> New symbol, add to image and library</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the reconstructed image and into the symbol bitmap library.</p>
</section><!-- 11.4.2 -->

<section id="11.4.3">
<h4><a href="#11.4.3">11.4.3</a> New symbol, add to library only</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the symbol bitmap library but not into the image.</p>
</section><!-- 11.4.3 -->

<section id="11.4.4">
<h4><a href="#11.4.4">11.4.4</a> New symbol, add to image only</h4>
<p>This record specifies the bitmap of a symbol that is coded directly and placed into the reconstructed image but not into the symbol bitmap library.</p>
</section><!-- 11.4.4 -->

<section id="11.4.5">
<h4><a href="#11.4.5">11.4.5</a> Matched symbol with refinement, add to image and library</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the reconstructed image and into the symbol bitmap library.</p>
</section><!-- 11.4.5 -->

<section id="11.4.6">
<h4><a href="#11.4.6">11.4.6</a> Matched symbol with refinement, add to library only</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the symbol bitmap library, but not into the reconstructed image.</p>
</section><!-- 11.4.6 -->

<section id="11.4.7">
<h4><a href="#11.4.7">11.4.7</a> Matched symbol with refinement, add to image only</h4>
<p>This record specifies the bitmap of a symbol that is coded by refinement of a symbol in the symbol bitmap library and placed into the reconstructed image, but not into the symbol bitmap library.</p>
</section><!-- 11.4.7 -->

<section id="11.4.8">
<h4><a href="#11.4.8">11.4.8</a> Matched symbol, copy to image without refinement</h4>
<p>This record specifies the location at which the bitmap of a symbol in the symbol bitmap library is to be placed into the reconstructed image.</p>
</section><!-- 11.4.8 -->

<section id="11.4.9">
<h4><a href="#11.4.9">11.4.9</a> Non-symbol data</h4>
<p>This record specifies a direct-coded bitmap to be placed at an absolute location in the reconstructed image. A bitmap of non-symbol data is not placed into the symbol bitmap library.</p>
</section><!-- 11.4.9 -->

<section id="11.4.10">
<h4><a href="#11.4.10">11.4.10</a> Shared dictionary or reset</h4>
<p>This record is overloaded and its meaning depends on its context. If the record occurs before a "Start of data" record, then it is a "Required dictionary" record. If the record occurs after a "Start of data" record then it is a "Reset" record.</p>

<section id="11.4.10.1">
<h5><a href="#11.4.10.1">11.4.10.1</a> Shared shape dictionaries</h5>
<p>Starting with version 21, the JB2 format provides support for sharing symbol definitions between the pages of a document. To achieve this objective, the JB2 image data chunk must be able to address symbols defined elsewhere by a JB2 dictionary data chunk shared by all the pages of a document.</p>
<p>A "Shared dictionary or reset" record can appear <em>before</em> the "Start of data" record. The record type field is followed by a single number arithmetically encoded using the sixteenth dictionary size context. This record appears when the JB2 data chunk requires symbols encoded in a separate JB2 dictionary data chunk. The number (the <i>dictionary size</i>) indicates how many symbols should have been defined by the JB2 dictionary data chunk. The decoder should simply load these symbols into the symbol library and proceed as usual. New symbols potentially defined by the subsequent JB2 image data records will therefore be numbered with integers greater than or equal to the dictionary size.</p>
</section><!-- 11.4.10.1 -->

<section id="11.4.10.2">
<h5><a href="#11.4.10.2">11.4.10.2</a> Numcoder reset</h5>
<p>The encoding of numbers potentially uses an unbounded number of binary coding contexts. These contexts are normally allocated when they are used for the first time (see <!-- TODO -->).</p>
<p>Starting with version 21, a "Shared dictionary or reset" record can appear <em>after</em> the "Start of data" record. The decoder should proceed with the next record after <em>clearing all binary contexts used for coding numbers</em>. This operation implies that all binary contexts previously allocated for coding numbers can be deallocated.</p>
<p>Starting with version 21, the JB2 encoder should insert a "Shared dictionary or reset" record whenever the number of these allocated binary contexts exceeds 20000. Only very large documents ever reach such a large number of allocated binary contexts (e.g.&nbsp;large maps). Hardware implementation however can benefit greatly from a hard bound on the total number of binary coding contexts. Old JB2 decoders will treat this record type as an "End of data" record and cleanly stop decoding (see <!-- TODO -->).</p>
</section><!-- 11.4.10.2 -->

<section id="11.4.10.3">
<h5><a href="#11.4.10.3">11.4.10.3</a> Record types in a shared dictionary</h5>
<p>The shared JB2 dictionary data format is a pure subset of the JB2 image data format:</p>
<ul>
<li>Required dictionary</li>
<li>Start of data</li>
<li>New symbol, add to library only</li>
<li>Matched symbol with refinement, add to library only</li>
<li>Numcoder reset</li>
<li>Comment</li>
<li>End of data</li>
</ul>
<p>Note that each shared dictionary can itself include another shared dictionary.</p>
<p>The JB2 dictionary data is usually located in an <span class="ck">Djbz</span> chunk. Each page may directly contain a <span class="ck">Djbz</span> chunk, or may indirectly point to such a chunk using an <span class="ck">INCL</span> chunk (see <!-- TODO -->).</p>
</section><!-- 11.4.10.3 -->
</section><!-- 11.4.10 -->

<section id="11.4.11">
<h4><a href="#11.4.11">11.4.11</a> Comment</h4>
<p>This record contains data whose interpretation is not specified by the standard.</p>
</section><!-- 11.4.11 -->

<section id="11.4.12">
<h4><a href="#11.4.12">11.4.12</a> End of data</h4>
<p>This record is the last record of an <span class="ck">Sjbz</span> chunk.</p>
</section><!-- 11.4.12 -->
</section><!-- 11.4 -->

<section id="11.5">
<h3><a href="#11.5">11.5</a> Fields</h3>
<p>The following fields are coded in records of the types specified in Table 6 and in §<a href="#11.4">11.4</a>.</p>

<section id="11.5.1">
<h4><a href="#11.5.1">11.5.1</a> Record type</h4>
<p>The record type is coded by the multivalue extension to the Z&prime;-Coder using the record type context. The range of allowable record types is from 0 to 11. The coded values are specified in the first column of Table 6.</p>
</section><!-- 11.5.1 -->

<section id="11.5.2">
<h4><a href="#11.5.2">11.5.2</a> Image size</h4>
<p>The width and height of the image are coded by the multivalue extension to the Z&prime;-Coder using the image size context. The width is coded first, then the height. The range of allowable values is from 0 to 262142. The width and height of a compound DjVu image or bi-level DjVu image must be the same as the width and height of the image specified in the <span class="ck">INFO</span> chunk.</p>
</section><!-- 11.5.2 -->

<section id="11.5.3">
<h4><a href="#11.5.3">11.5.3</a> Eventual image refinement flag</h4>
<p>The eventual image refinement flag is coded once, in the "Start of image" record, to notify the decoder whether image refinement data will eventually be provided. It is a binary value, coded by the Z&prime;-Coder using the eventual image refinement context. The coded value 1 means <code>TRUE</code> and the coded value 0 means <code>FALSE</code>. Note: this flag is always <code>FALSE</code> in the current version of the standard, but it may be <code>TRUE</code> in later versions.</p>
</section><!-- 11.5.3 -->

<section id="11.5.4">
<h4><a href="#11.5.4">11.5.4</a> Index of matching symbol in bitmap library</h4>
<p>The index of a matching symbol in the bitmap library is coded with the multivalue extension to the Z&prime;-Coder, using the matching symbol index context. The range of allowable values is from 0 to one less than the number of symbols currently in the bitmap library.</p>
</section><!-- 11.5.4 -->

<section id="11.5.5">
<h4><a href="#11.5.5">11.5.5</a> Absolute symbol size</h4>
<p>The width of a symbol is coded by the multivalue extension to the Z&prime;-Coder using the symbol width context. Then the height of the symbol is coded by the multivalue extension to the Z&prime;-Coder using the symbol height context. The range of allowable values for both of these data elements is from 0 to 262142.</p>
</section><!-- 11.5.5 -->

<section id="11.5.6">
<h4><a href="#11.5.6">11.5.6</a> Relative symbol size</h4>
<p>The signed differences between the width and height of the current symbol and the width and heigh of the matching symbol are coded by the multivalue extension to the Z&prime;-Coder using the symbol width different context and the symbol height difference context for the height. The width difference is coded first, then the height difference. The coded signed difference is added to the width or height of the matching symbol to obtain the width or height of the current symbol. The range of allowable values for both of these data elements is from -262143 to 262142.</p>
</section><!-- 11.5.6 -->

<section id="11.5.7">
<h4><a href="#11.5.7">11.5.7</a> Absolute location</h4>
<p>The horizontal and vertical positions of the upper left corner of the bitmap are coded by the multivalue extension to the Z&prime;-Coder using the symbol column number context for the horizontal position and the symbol row number context for the vertical position. The horizontal position is coded first, then the vertical position. The range of allowable values for the horizontal position is from 1 to the width of the image in pixels. The range of allowable values for the vertical position is from 1 to the height of the image in pixels.</p>
</section><!-- 11.5.7 -->

<esction id="11.5.8">
<h4><a href="#11.5.8">11.5.8</a> Location relative to a previous symbol</h4>
<p>The offset type flag is coded by the Z&prime;-Coder using the offset type context. It indicates the reference symbol for coding the offset of the location of the current symbol. The coded value 1 means <code>FIRST</code>, which means that the location of the current symbol is being specified relative to the first symbol on the current text line. The value 0 means <code>PREVIOUS</code>, which means that the location of the current symbol is being specified relative to the most recently coded symbol on the current text line.</p>
<p>If the offset type flag is <code>FIRST</code>, then the reference symbol is the first symbol on the current text line. The horizontal offset is the signed difference between the left edge of the current symbol and the left edge of the reference symbol. It is coded with the multivalue extension to the Z&prime;-Coder using the new line column offset context.</p>
</section><!-- 11.5.8 -->

<section id="11.5.9">
<h4><a href="#11.5.9">11.5.9</a> Bitmap by direct coding</h4>
<p>Non-symbol bitmaps and symbol bitmaps with no sufficiently closely matching symbol in the symbol library are coded directly. A directly-coded bitmap is coded by repeated applications of the Z&prime;-Coder to the pixels of the bitmap left to right across the rows, starting with the top row. When one row has been coded, the next lower row is coded. Each pixel is coded by the Z&prime;-Coder using an appropriate context based on the values of 10 previously coded pixels. A coded value of 1 means the pixel is black. A coded value of 0 means the pixel is white.</p>
<p>The colors of the pixels numbered 1 through 10 in Figure 2, taken collectively, form a 10-bit value. Each of these values is an index into a table of 1024 different directly-coded bitmap contexts. The pixel labeled <i>P</i> in Figure 2 is coded using the context indexed by the collective values of the other 10 numbered pixels in the template. Pixels outside the bounding box are considered to be white.</p>
<figure>
<!-- TODO -->
<figcaption>Figure 2: template for direct coding</figcaption>
</figure>
</section><!-- 11.5.9 -->

<section id="11.5.10">
<h4><a href="#11.5.10">11.5.10</a> Bitmap by refinement coding</h4>
<p>Some bitmaps are coded by making use of data from another bitmap; this process is called <i>refinement coding</i>. Matched symbols other than those to be copied are coded using refinement coding.</p>
<p>A bitmap coded by refinement coding is coded by repeated application of the Z&prime;-Coder to the pixels of the bitmap, left to right across the rows. When one row has been coded, the next lower row is coded. Each pixel is coded by the Z&prime;-Coder using an appropriate context based on the values of four previously coded pixels from the bitmap being coded and seven pixels from the matching bitmap. (The pixels numbered 1 through 4 in Figure 3 are from the current symbol; the pixels numbered 5 through 11 are from the matching symbol.) A coded value of 1 means the pixel is black. A coded value of 0 means the pixel is white. The colors of the pixels numbered 1 through 11 in Figure 3, taken collectively, form an 11-bit value. Each of these values is an index into a table of 2048 different refinement-coded bitmap contexts. The pixel labeled <i>P</i> in Figure 3 is coded using the context indexed by the collective values of the 11 numbered pixels in the template. Pixel 7 is in the position in the matching symbol that corresponds to the position of pixel <i>P</i> in the current symbol when the two symbols are aligned.</p>
<p>Alignment of the current bitmap and the matching bitmap proceeds as follows. For matched symbols, the current symbol and the matching symbol are aligned according to the geometric centers of their bounding rectangles. If the number of columns or rows is even, the geometric center falls between two columns or rows, respectively. In this case, the leftmost of the two central columns or the lowermost of the two central rows is considered to be the central column or row, respectively.</p>
<figure>
<!-- TODO -->
<figcaption>Figure 3: template for refinement coding. (a) Pixels from symbol being coded from matching symbol. (b) Pixels from matching symbol.</figcaption>
</figure>
<p>It is possible for the current symbol to have empty edge rows or columns. These empty rows and columns are coded, and are included in the bounding rectangle. For symbols added to the library, the symbol is added to the library after it has been placed into the image. Any empty edge rows and columns are removed before the symbol is added to the library.</p>
</section><!-- 11.5.10 -->

<section id="11.5.11">
<h4><a href="#11.5.11">11.5.11</a> Comment length</h4>
<p>The comment length is the number of octets in the comment. It is coded by the multivalue extension to the Z&prime;-Coder using the comment length context. The range of allowable values for the comment length is from 0 to 262142.</p>
</section><!-- 11.5.11 -->

<section id="11.5.12">
<h4><a href="#11.5.12">11.5.12</a> Comment data</h4>
<p>Comment data consists of the individual octets of the comment. The number of octets in the comment is given by the comment length field. Each of the octets is coded using the multivalue extension to the Z&prime;-Coder using the comment octet context. The range of allowable values for each octet is from 0 to 255.</p>
</section><!-- 11.5.12 -->
</section><!-- 11.5 -->
</section><!-- 11 -->

<section id="12">
<h2><a href="#12">12</a> Appendix 3: Z&prime; coding <small>[<a href="#">top</a>]</small></h2>
<p>The Z&prime;-Coder is an approximate binary arithmetic coder. Decoding proceeds as follows.<sup>[<a id="note-12-1" href="./spec-comments.html#12-1">1</a>]</sup></p>
<p>See also files <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.h">ZPCodec.h</a> and <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/ZPCodec.cpp">ZPCodec.cpp</a> in DjVuLibre.</p>

<section id="12.1">
<h3><a href="#12.1">12.1</a> Registers and data storage</h3>
<p>In Figure 1 and Figure 2, the values of variables <var>A</var>, <var>C</var>, <var>D</var>, and <var>Z</var> are stored in registers of at least 16 bits each. <var>A</var> and <var>C</var> retain their values between invocations of the Z&prime;-Coder. Note: if register overflow can be ignored, storing variables <var>A</var> and <var>C</var> in registers of exactly 16 bits allows a simplification of lines 11, 12, 16, and 17 of Figure 1 and lines 8, 9, 12, and 13 of Figure 2.</p>
<p>At the beginning of a chunk, the values of <var>A</var> and <var>C</var> are reinitialized. When the decoder is decoding a chunk, it may require more bits than are present within the chunk’s data. In this case, all additional required bits are to be assumed by the decoder to be 1. If there are excess bits at the end of a chunk, they are ignored.</p>
<p><var>K</var> is conceptually an array with a single 8-bit entry for each binary decision context. (In practice, <var>K</var> consists of a number of of individual values, arrays, and tree nodes, but each one has a specific address and a single 8-bit value at any time.) This array is indexed by the value of <var>i</var>, which is the input to the decoder.
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>
is the current value of the probability state index for context <var>i</var>.
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>
may be updated as part of the decoding process.</p>
<p>In pass-through mode, the decoder is invoked with no input argument. No context is involved.</p>
<p><var>B</var> is the 1-bit value returned by the decoder.</p>
<p>The Z&prime;-Coder is state-based. Decoding is governed by four fixed tables, given in Table 9. The tables are indexed by
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
  </mrow>
</math>,
the probability state index for the current context. All probability state indices are initialized to 0. That is, at the beginning of coding, for all <var>i</var>,
<math>
  <mrow>
    <mi>K</mi>
    <mo stretchy="false" form="prefix">[</mo>
    <mi>i</mi>
    <mo stretchy="false" form="postfix">]</mo>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>.
These values are not reinitialized at the beginning of chunks after the first.</p>
<p>The more probably symbol is denoted by MPS. The MPS is 1 if the probability state index is an odd integer, and 0 if the probability state index is an even integer. The less probable symbol is denoted by LPS. The LPS is 0 if the probability state index is an odd integer, and 1 if the probability state context is an even integer.</p>
<p>
<math>
  <msub>
    <mi>Δ</mi>
    <mi>k</mi>
  </msub>
</math>
is the amount by which the current arithmetic coding interval is reduced if the decoded symbol is the MPS.
<math>
  <msub>
    <mi>θ</mi>
    <mi>k</mi>
  </msub>
</math>
is the threshold above which an MPS triggers a probability state update.
<math>
  <msub>
    <mi>μ</mi>
    <mi>k</mi>
  </msub>
</math>
is the next probability state index for context <var>k</var> after an MPS triggers a probability state index update. An LPS always triggers a probability state index update.
<math>
  <msub>
    <mi>λ</mi>
    <mi>k</mi>
  </msub>
</math>
is the next probability state index for context <var>k</var> after an LPS.</p>
</section><!-- 12.1 -->

<section id="12.2">
<h3><a href="#12.2">12.2</a> Initialization</h3>
<p>Initially, <var>A</var> is set to <span class="hex">0x0000</span>. Two octets are read from the input data stream into the lowest 16 bits of <var>C</var>. If the bits of <var>C</var> are numbered such that bit 15 is the most significant bit and bit 0 is the least significant bit, then the first input octet is stored in bits 15 through 8, and the second input octet is stored in bits 7 through 0.</p>
</section><!-- 12.2 -->

<section id="12.3">
<h3><a href="#12.3">12.3</a> Decoding</h3>
<p>Figure 1 shows the steps involved in decoding a single binary decision. The input to the decoder is the index <var>i</var> of the appropriate context for the binary decision being decoded. The output from the decoder is a single bit <var>B</var>.</p>
<figure id="figure-1">
<pre>
<code>Z := A + Δ<sub>K[i]</sub></code>
<code>D := 0x6000 + (Z + A)/4</code>
<code>if (Z &gt; D) { Z := D }</code>
<code>if (C &gt; Z) {</code>
    <code>B := K[i] mod 2</code>
    <code>if (A &geq; θ<sub>K[i]</sub>) { K[i] = μ<sub>K[i]</sub> }</code>
    <code>A := Z</code>
<code>}</code>
<code>else {</code>
    <code>B := 1 - (K[i] mod 2)</code>
    <code>A := A + 0x10000 - Z</code>
    <code>C := C + 0x10000 - Z</code>
    <code>K[i] = λ<sub>K[i]</sub></code>
<code>}</code>
<code>while (A &geq; 0x8000) {</code>
    <code>A := A + A - 0x10000</code>
    <code>A := C + C - 0x10000 + next code bit</code>
<code>}</code>
<code>return B</code>
</pre>
<figcaption>Figure 1: decoder for the Z&prime;-Coder</figcaption>
</figure>

<section id="12.3.1">
<h4><a href="#12.3.1">12.3.1</a> Notes on specific lines of Figure 1</h4>
<dl>
<dt>Line 2</dt>
<dd>The division is a right shift, discarding the two least significant bits.</dd>
<dt>Lines 4–8</dt>
<dd>These lines are executed when the decoded bit is the MPS.</dd>
<dt>Line 5</dt>
<dd>This line determines the MPS from from the parity of the probability state index.</dd>
<dt>Line 6</dt>
<dd>Sometimes an MPS event triggers an update of the probability state index, based on the value of
<math>
  <msub>
    <mi>θ</mi>
    <mi>k</mi>
  </msub>
</math>.
Note that when the probability state index
<math>
  <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
or
<math>
  <mrow>
    <mi>k</mi>
    <mo>&gt;</mo><!-- FIXME -->
    <mn>83</mn>
  </mrow>
</math>,
<math>
  <mrow>
    <msub>
      <mi>θ</mi>
      <mi>k</mi>
    </msub>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>,
so an MPS will trigger an update of the probability state index. All probability state indices are initialized to 0, but the first coded decision for a context causes the index to become at least 83. When
<math>
  <mrow>
    <mi>k</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
or
<math>
  <mrow>
    <mi>k</mi>
    <mo>≥</mo>
    <mn>83</mn>
  </mrow>
</math>,
the probability estimate for the context is in its early estimation phase. When
<math>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>k</mi>
    <mo>&lt;</mo>
    <mn>83</mn>
  </mrow>
</math>,
the probability estimate for the context is in its steady-state phase, which it never leaves.</dd>
<dt>Lines 9–14</dt>
<dd>These lines are executed when the decoded bit is the LPS.</dd>
<dt>Line 10</dt>
<dd>This line determines the LPS from the parity of the probability state index.</dd>
<dt>Line 13</dt>
<dd>An LPS always triggers an update of the probability state index.</dd>
<dt>Lines 15–18</dt>
<dd>When the values in the registers are too large, they must be renormalized.</dd>
<dt>Lines 16–17</dt>
<dd>
<math>
  <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>A</mi>
  </mrow>
</math>
and
<math>
  <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mi>C</mi>
  </mrow>
</math>
may be accomplished by left shifts, leaving the least significant bit equal to 0.</dd>
<dt>Line 17</dt>
<dd>The least significant bit of <var>C</var> is filled with the next bit from the input stream. Bits are taken from each octet in the input stream most significant bit first.</dd>
</dl>
</section><!-- 12.3.1 -->
</section><!-- 12.3 -->

<section id="12.4">
<h3><a href="#12.4">12.4</a> Pass-through decoding</h3>
<p>Figure 2 shows the steps involved in decoding a single binary decision using the Z&prime;-Coder in pass-through mode. No input is required. No context is involved. No probability state index values are updated. The output from the decoder is the single bit <var>B</var>.</p>
<figure id="figure-2">
<pre>
<code>Z := 0x8000 + (A + A + A)/8</code>
<code>if (C &gt; Z) {</code>
    <code>B := 0</code>
    <code>A := Z</code>
<code>}</code>
<code>else {</code>
    <code>B := 1</code>
    <code>A := A + 0x10000 - Z</code>
    <code>C := C + 0x10000 - Z</code>
<code>}</code>
<code>while (A &geq; 0x8000) {</code>
    <code>A := A + A - 0x10000</code>
    <code>A := C + C - 0x10000 + next code bit</code>
<code>}</code>
<code>return B</code>
</pre>
<figcaption>Figure 2: decoder for the Z&prime;-Coder operating in pass-through mode</figcaption>
</figure>

<section id="12.4.1">
<h4><a href="#12.4.1">12.4.1</a> Notes on specific lines of Figure 2</h4>
<dl>
<dt>Line 1</dt>
<dd>The division is a right shift, discarding the three least significant bits.</dd>
<dt>Lines 2–5</dt>
<dd>These lines are executed when the decoded bit is 0.</dd>
<dt>Lines 6–10</dt>
<dd>These lines are executed when the decoded bit is 1.</dd>
<dt>Lines 11–14</dt>
<dd>When the values in the registers are too large, they must be renormalized.</dd>
<dt>Lines 12–13</dt>
<dd>
<math>
  <mrow>
    <mi>A</mi>
    <mo>+</mo>
    <mi>A</mi>
  </mrow>
</math>
and
<math>
  <mrow>
    <mi>C</mi>
    <mo>+</mo>
    <mi>C</mi>
  </mrow>
</math>
may be accomplished by left shifts, leaving the least significant bit equal to 0.</dd>
<dt>Line 13</dt>
<dd>The least significant bit of <var>C</var> is filled with the next bit from the input stream. Bits are taken from each octet in the input stream most significant bit first.</dd>
</dl>
</section><!-- 12.4.1 -->
</section><!-- 12.4 -->
</section><!-- 12 -->

<section id="13">
<h2><a href="#13">13</a> Appendix 4: BZZ coding <small>[<a href="#">top</a>]</small></h2>
<p>Numerous streams in the DjVu file format are compressed using the general-purpose compressor described here called “BZZ”. BZZ transforms the input data using the well-documented Burrows–Wheeler transform. However, the traditional “Move To Front” permutation table is augmented with a frequency estimation provided by the Z&prime;-Coder.</p>
<p>See also file <a class="filename" href="https://sourceforge.net/p/djvu/djvulibre-git/ci/master/tree/libdjvu/BSByteStream.cpp">BSByteStream.cpp</a>.</p>

<section id="13.1">
<h3><a href="#13.1">13.1</a> Encoding</h3>
<p>BZZ first takes as input a 24-bit integer as block size between 10K and 4M and an input stream (to be compressed). The stream is partitioned into blocks terminated with a special <code>&langle;EOB&rangle;</code> symbol. It is then transformed using the well-documented Burrows–Wheeler (BW or “block sorting”) transform. Then, one block at a time, the block size and resulting output stream are passed as input to be compressed using the Z&prime;-Coder (<a href="#12">Appendix 3</a>).</p>
</section><!-- 13.1 -->

<section id="13.2">
<h3><a href="#13.2">13.2</a> Decoding</h3>
<p>We describe the decoding algorithm by means of pseudo-code.</p>

<section id="13.2.1">
<h4><a href="#13.2.1">13.2.1</a> Decoding pseudo-code</h4>
<!-- TODO -->
</section><!-- 13.2.1 -->

<section id="13.2.2">
<h4><a href="#13.2.2">13.2.2</a> Notes</h4>

<section id="13.2.2.1">
<h5><a href="#13.2.2.1">13.2.2.1</a> Overview of decoding a block</h5>
<p>For each block, one must decode</p>
<ul>
<li>the block size (with <code>decode_raw</code>)</li>
<li>the estimation speed <code>FSHIFT ∈ {0, 1, 2}</code> (two bits<sup>[<a id="note-13.2.2.1-1" href="./spec-comments.html#13.2.2.1-1">1</a>]</sup> with the pass-through decoder)</li>
<li>the sequence of symbols representing the Burrows–Wheeler transform of the block. At this point, the sequence of symbols is logically encoded as a sequence of numbers representing the position of each symbol in the MTF array.</li>
</ul>
<p>Then one must perform the inverse Burrows–Wheeler transform to recover the decoded block.</p>
<p>The following points are significant when recovering the BWT and are discussed below:</p>
<ul>
<li>The MTF array is reordered after decoding each number.</li>
<li>The numbers themselves are arithmetically encoded.</li>
</ul>
</section><!-- 13.2.2.1 -->

<section id="13.2.2.2">
<h5><a href="#13.2.2.2">13.2.2.2</a> MTF array reordering</h5>
<p>The MTF array contains 256 bytes initialized with the identity mapping, that is <code>MTF[0] = 0</code>, <code>MTF[1] = 1</code>, … , <code>MTF[255] = 255</code>.</p>
<p>Whenever one decodes a number <code>MTFNO</code>, the corresponding symbol to store in the Burrows–Wheeler buffer is <code>MTF[MTFNO]</code> (except for the <code>&langle;EOB&rangle;</code> symbol — see §<a href="#13.2.2.3">13.2.2.3</a>) and the contents of the MTF array are rotated. The rotation moves the symbol that was at position <code>MTF[MTFNO]</code><!-- FIXME --> to a position <code>M</code> that can be 0, 1, 2, or 3. Meanwhile the symbols <code>MTF[M]</code> to <code>MTF[MTFNO - 1]</code> are moved to positions <code>M + 1</code> to <code>MTFNO</code>.</p>
<p>The position <code>M</code> is chosen using an estimate of the frequency of the symbol <code>MTF[MTFNO]</code>. One strives to position the most frequent symbols at the beginning of the MTF array. To that end, one maintains an array <code>FREQ[0..3]</code> that contains numbers representative of the instantaneous frequencies of the symbols <code>MTF[0..3]</code>.</p>
<p>Of course this array must also be “rotated” when the rotation of the MTF array affects its first four elements.</p>
<p>Consider the frequency
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of a particular symbol <var>S</var> measured after decoding the <var>T</var>th symbol. Ideally,
<math display="block">
  <mrow>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>λ</mi>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
  </mrow>
</math>
where</p>
<ul>
<li>
<math>
  <mrow>
    <mn>0</mn>
    <mo>&lt;</mo>
    <mi>λ</mi>
    <mo>≤</mo>
    <mn>1</mn>
  </mrow>
</math>.
This models how quickly one forgets past information, and
</li>
<li>
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>
if the <var>T</var>th symbol is <var>S</var>, and
<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
otherwise. This allows
<math>
  <mi>F</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
to grow each time the symbol <var>S</var> occurs.
</li>
</ul>
<p>To avoid multiplying all the frequencies by <math><mi>λ</mi></math>, the <code>FREQ</code> array contains instead
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>F</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
It is then easy to see that
<math display="block">
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
    <mi>D</mi>
    <mi>/</mi>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>
Therefore we only need to update the <var>G</var> corresponding to the symbol being decoded (i.e.&nbsp;<math>
  <mrow>
    <mi>D</mi>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>),
since the <var>G</var> for the other symbols does not change.</p>
<p>A dedicated variable <code>FADD</code> contains
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
Before each rotation we divide <code>FADD</code> by 
<math>
  <mrow>
    <msup>
      <mi>λ</mi>
      <mi>T</mi>
    </msup>
  </mrow>
</math>.
This is accomplished by the line
<pre>
<code>FADD = FADD + SHIFTRIGHT(FADD, FSHIFT)</code>
</pre>
<p>The values 0, 1 or 2 of variable <code>FSHIFT</code> correspond to
<math>
  <mrow>
    <mi>λ</mi>
    <mo>=</mo>
    <mn>1</mn>
    <mi>/</mi>
    <mn>2</mn>
  </mrow>
</math>,
<math><mn>2</mn><mi>/</mi><mn>3</mn></math>, or
<math><mn>4</mn><mi>/</mi><mn>5</mn></math>.
To avoid overflows we divide everything (<code>FADD</code> and <code>FREQ[0..3]</code>) by <code>0x10000000</code> whenever <code>FADD</code> becomes bigger than <code>0x10000000</code>. This happens rarely enough to take very little time.</p>
<p>The
<math>
  <mi>G</mi>
  <mo stretchy="false" form="prefix">(</mo>
  <mi>T</mi>
  <mo stretchy="false" form="postfix">)</mo>
</math>
of the freshly decoded symbol is therefore
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>+</mo>
  </mrow>
</math><code>FADD</code>.
We can only compute this exactly when <math><mi>S</mi></math> is one of the first four symbols of the MTF because we only store <code>FREQ[0..3]</code>. If the decoded number <code>MTFNO</code> is greater than 3, we assume that 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo>−</mo>
    <mn>1</mn>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
    <mn>0</mn>
  </mrow>
</math>
and simply consider 
<math>
  <mrow>
    <mi>G</mi>
    <mo stretchy="false" form="prefix">(</mo>
    <mi>T</mi>
    <mo stretchy="false" form="postfix">)</mo>
    <mo>=</mo>
  </mrow>
</math><code>FADD</code>.</p>
<p>The number <code>M</code> is then chosen to make sure the array <code>FREQ</code> remains sorted in decreasing order after the rotation.</p>
</section><!-- 13.2.2.2 -->

<section id="13.2.2.3">
<h5><a href="#13.2.2.3">13.2.2.3</a> Decoding the number <code>MTFNO</code></h5>
<p>Now we can discuss how the numbers <code>MTFNO</code> are stored. There are 262 arithmetic coding contexts. These are initialized to zero at the beginning of the stream decoding process. They should <em>not</em> be reset to zero at the beginning of the block decoding process.</p>
<p>Because the most frequently used symbols should appear near the front of the array, we expect small values for <code>MTFNO</code> (the index into the MTF array). By design, the number of bits and the number of contexts required to decode increases for larger values of <code>MTFNO</code>:</p>
<ul>
<li>A first bit is decoded using context 0, 1 or 2. Context 0 or 1 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 2 is used. If this bit is set, the new <code>MTFNO</code> is 0.</li>
<li>Otherwise a second bit is decoded using context 3, 4 or 5. Context 3 or 4 is used if the previous <code>MTFNO</code> was 0 or 1. Otherwise context 5 is used. If this bit is set, the new <code>MTFNO</code> is 1.</li>
<li>Otherwise a third bit is decoded using context 6. If this bit is set, the new <code>MTFNO</code> is obtained by adding 2 to a 1-bit number decoded with <code>decode_bin</code> using context 7.</li>
<li>Otherwise a fourth bit is decoded using context 8. If this bit is set, the new <code>MTFNO</code> is obtained by adding 4 to a 2-bit number decoded with <code>decode_bin</code> using contexts <code>9..11</code>.</li>
<li>And so forth until…</li>
<li>Otherwise a ninth bit is decoded using context 132. If this bit is set, the new <code>MTFNO</code> is obtained by adding 128 to a 7-bit number decoded with <code>decode_bin</code> using contexts <code>133..261</code>.</li>
<li>Otherwise the next symbol is the <code>&langle;EOB&rangle;</code> symbol. Since there is only one <code>&langle;EOB&rangle;</code> symbol, we store a zero in the Burrows–Wheeler buffer and record its position in variable <code>MARKERPOS</code>.</li>
</ul>
</section><!-- 13.2.2.3 -->

<section id="13.2.2.4">
<h5><a href="#13.2.2.4">13.2.2.4</a> Inverse Burrows–Wheeler transform</h5>
<p>After decoding the <code>BLOCKSIZE</code> symbols composing the Burrows–Wheeler buffer, we need to perform the inverse Burrows–Wheeler transform to recover the <code>BLOCKSIZE - 1</code> decoded bytes followed by the <code>&langle;EOB&rangle;</code> symbol.</p>
<p>To start, we</p>
<ul>
<li>copy the buffer into an array <code>POSC[0..BLOCKSIZE - 1]</code>,</li>
<li>prepare an array <code>COUNT[0..255]</code> that counts how many occurrences of each symbol are found,</li>
<li>prepare an array <code>POSN[0..BLOCKSIZE - 1]</code> that indicates the rank of each occurrence of a symbol in the buffer.</li>
</ul>
<p>Imagine that we are sorting the buffer in symbol order (<code>&langle;EOB&rangle;</code> being the smallest symbol). The buffer would be composed of a single <code>&langle;EOB&rangle;</code>, followed by a run of <code>COUNT[0]</code> symbols 0, followed by a run of <code>COUNT[1]</code> symbols 1, etc.</p>
<p>Using the <code>COUNT</code> array, we compute the position <code>SORTEDPOS[0..255]</code> of each run of symbol in this array.</p>
<p>To perform the inverse Burrows–Wheeler transform, it is now sufficient to follow the thread backwards:</p>
<pre>
<!-- TODO -->
</pre>
The array <code>DATA[0..BLOCKSIZE - 2]</code> then contains the decoded bytes of the block.
</section><!-- 13.2.2.4 -->
</section><!-- 13.2.2 -->
</section><!-- 13.2 -->
</section><!-- 13 -->

</body>
</html>
